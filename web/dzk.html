<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MD3 Brick Breaker</title>
    <style>
        :root {
            /* MD3 Color Tokens (Dark Theme) */
            --md-sys-color-surface: #141218;
            --md-sys-color-surface-container: #211f26;
            --md-sys-color-primary: #d0bcff;
            --md-sys-color-on-primary: #381e72;
            --md-sys-color-primary-container: #4f378b;
            --md-sys-color-on-primary-container: #eaddff;
            --md-sys-color-secondary: #ccc2dc;
            --md-sys-color-tertiary: #efb8c8;
            --md-sys-color-error: #f2b8b5;
            --md-sys-color-outline: #938f99;
            --font-family: 'Roboto', system-ui, -apple-system, sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Á¶ÅÊ≠¢ÊµèËßàÂô®ÈªòËÆ§Ëß¶Êë∏Ë°å‰∏∫ */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-secondary);
            font-family: var(--font-family);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Game Container */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px; /* Âπ≥Êùø/Ê°åÈù¢ÈôêÂà∂ÂÆΩÂ∫¶ */
            display: flex;
            flex-direction: column;
        }

        /* Top Bar: Score & Settings */
        .top-bar {
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 80px;
            background-color: var(--md-sys-color-surface);
            z-index: 10;
        }

        .score-board {
            font-size: 24px;
            font-weight: 500;
            color: var(--md-sys-color-primary);
        }

        .btn-icon {
            background: var(--md-sys-color-surface-container);
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--md-sys-color-primary);
            transition: background 0.2s, transform 0.1s;
        }

        .btn-icon:active {
            background: var(--md-sys-color-primary-container);
            transform: scale(0.95);
        }

        /* Canvas Area */
        canvas {
            flex: 1;
            width: 100%;
            height: 100%;
            display: block;
            background: radial-gradient(circle at center, #1e1b26 0%, #141218 100%);
        }

        /* UI Overlays (Menu/Game Over) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 18, 24, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            transition: opacity 0.3s;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .card {
            background: var(--md-sys-color-surface-container);
            padding: 32px;
            border-radius: 28px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            max-width: 80%;
            width: 320px;
        }

        h1 {
            margin: 0 0 16px 0;
            font-size: 32px;
            color: var(--md-sys-color-primary);
        }

        p {
            margin: 0 0 32px 0;
            font-size: 16px;
            line-height: 1.5;
        }

        /* MD3 Filled Button */
        .btn-primary {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            height: 40px;
            padding: 0 24px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.1px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }

        .btn-primary:active {
            box-shadow: none;
            transform: translateY(2px);
            filter: brightness(0.9);
        }

        /* Icons SVG */
        svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        /* Ripple effect container */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0);
            animation: ripple 0.6s linear;
            pointer-events: none;
        }

        @keyframes ripple {
            to { transform: scale(4); opacity: 0; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- Top Bar -->
    <div class="top-bar">
        <div class="score-board">
            Score: <span id="score-val">0</span>
        </div>
        <button id="btn-sound" class="btn-icon" aria-label="Toggle Sound">
            <!-- Sound On Icon -->
            <svg id="icon-sound-on" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
            <!-- Sound Off Icon (Hidden by default) -->
            <svg id="icon-sound-off" style="display:none" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
        </button>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Start/Game Over Screen -->
    <div id="menu-overlay" class="overlay">
        <div class="card">
            <h1 id="menu-title">Brick Breaker</h1>
            <p id="menu-desc">ÊãñÂä®Êå°ÊùøÂèçÂºπÂ∞èÁêÉ<br>ÊâìÁ†¥ÊâÄÊúâÁ†ñÂùó</p>
            <button id="btn-start" class="btn-primary">ÂºÄÂßãÊ∏∏Êàè</button>
        </div>
    </div>
</div>

<script>
/**
 * Ê∏∏ÊàèÊ†∏ÂøÉÈÄªËæë
 * ÂåÖÂê´ÔºöÁâ©ÁêÜÂºïÊìé„ÄÅÊ∏≤ÊüìÂæ™ÁéØ„ÄÅÁä∂ÊÄÅÁÆ°ÁêÜ„ÄÅÈü≥ÊïàÁ≥ªÁªü
 */

// --- Audio System (Web Audio API) ---
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
    }

    toggle() {
        this.enabled = !this.enabled;
        if (this.enabled && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        return this.enabled;
    }

    playTone(freq, type, duration, vol=0.1) {
        if (!this.enabled) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playBounce() { this.playTone(440, 'sine', 0.1, 0.1); }
    playPaddleHit() { this.playTone(600, 'triangle', 0.1, 0.15); }
    playBrickHit() { 
        // ÈöèÊú∫Èü≥È´òÔºåÂ¢ûÂä†Ë∂£Âë≥ÊÄß
        const freq = 300 + Math.random() * 200;
        this.playTone(freq, 'square', 0.15, 0.1); 
    }
    playGameOver() { 
        this.playTone(150, 'sawtooth', 1.0, 0.3); 
        if (navigator.vibrate) navigator.vibrate(400);
    }
    playWin() {
        this.playTone(523.25, 'sine', 0.2, 0.2);
        setTimeout(() => this.playTone(659.25, 'sine', 0.2, 0.2), 200);
        setTimeout(() => this.playTone(783.99, 'sine', 0.4, 0.2), 400);
    }
}

// --- Particle System for Visuals ---
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = 0.02 + Math.random() * 0.03;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        return this.life > 0;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// --- Game Logic ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const soundManager = new SoundManager();

// State
let animationId;
let score = 0;
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, WON
let particles = [];

// Physics configs (Dynamic based on screen size)
let GAME_WIDTH, GAME_HEIGHT;
const PADDLE_height = 16;
let PADDLE_WIDTH, PADDLE_X;
let BALL_RADIUS;
let ball = { x: 0, y: 0, dx: 0, dy: 0, speed: 0 };
let bricks = [];
const BRICK_ROWS = 6;
const BRICK_COLS = 5;
let BRICK_WIDTH, BRICK_HEIGHT, BRICK_PADDING, BRICK_OFFSET_TOP, BRICK_OFFSET_LEFT;

// MD3 Colors for Drawing
const COLORS = {
    ball: '#eaddff',
    paddle: '#d0bcff',
    brick: ['#ffb4ab', '#e8def8', '#f2b8b5', '#d0bcff', '#ccc2dc'],
    text: '#e6e1e5'
};

// Resize Handling
function resize() {
    canvas.width = canvas.parentElement.clientWidth * window.devicePixelRatio;
    canvas.height = canvas.parentElement.clientHeight * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    
    GAME_WIDTH = canvas.parentElement.clientWidth;
    GAME_HEIGHT = canvas.parentElement.clientHeight;

    // Responsive Sizes
    PADDLE_WIDTH = GAME_WIDTH * 0.25; // 25% of screen width
    BALL_RADIUS = GAME_WIDTH * 0.02;  // 2% of screen width

    BRICK_PADDING = 10;
    BRICK_OFFSET_LEFT = 20;
    BRICK_OFFSET_TOP = 60;
    const availableWidth = GAME_WIDTH - (2 * BRICK_OFFSET_LEFT);
    BRICK_WIDTH = (availableWidth - (BRICK_COLS - 1) * BRICK_PADDING) / BRICK_COLS;
    BRICK_HEIGHT = GAME_HEIGHT * 0.03;

    if (gameState === 'MENU' || gameState === 'GAMEOVER') {
        resetBallPaddle();
    }
}

function resetBallPaddle() {
    PADDLE_X = (GAME_WIDTH - PADDLE_WIDTH) / 2;
    ball.x = GAME_WIDTH / 2;
    ball.y = GAME_HEIGHT - 50;
    ball.speed = GAME_HEIGHT * 0.008; // Proportional speed
    ball.dx = ball.speed * (Math.random() > 0.5 ? 1 : -1);
    ball.dy = -ball.speed;
}

function initBricks() {
    bricks = [];
    for(let c=0; c<BRICK_COLS; c++) {
        bricks[c] = [];
        for(let r=0; r<BRICK_ROWS; r++) {
            bricks[c][r] = { 
                x: 0, y: 0, 
                status: 1,
                color: COLORS.brick[r % COLORS.brick.length]
            };
        }
    }
}

// Input Handling
let isTouching = false;

function touchHandler(e) {
    if (gameState !== 'PLAYING') return;
    const touch = e.touches ? e.touches[0] : e;
    const rect = canvas.getBoundingClientRect();
    const relativeX = touch.clientX - rect.left;

    if(relativeX > 0 && relativeX < GAME_WIDTH) {
        PADDLE_X = relativeX - PADDLE_WIDTH/2;
        
        // Clamp paddle to screen
        if (PADDLE_X < 0) PADDLE_X = 0;
        if (PADDLE_X + PADDLE_WIDTH > GAME_WIDTH) PADDLE_X = GAME_WIDTH - PADDLE_WIDTH;
    }
}

canvas.addEventListener("touchstart", (e) => { isTouching = true; touchHandler(e); }, {passive: false});
canvas.addEventListener("touchmove", (e) => { e.preventDefault(); touchHandler(e); }, {passive: false});
canvas.addEventListener("touchend", () => { isTouching = false; });
canvas.addEventListener("mousemove", touchHandler);

// Game Loop Functions
function drawBall() {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2);
    ctx.fillStyle = COLORS.ball;
    ctx.fill();
    ctx.shadowColor = COLORS.ball;
    ctx.shadowBlur = 10;
    ctx.closePath();
    ctx.shadowBlur = 0; // Reset
}

function drawPaddle() {
    ctx.beginPath();
    // Rounded rectangle
    const r = PADDLE_height / 2;
    ctx.roundRect(PADDLE_X, GAME_HEIGHT - PADDLE_height - 10, PADDLE_WIDTH, PADDLE_height, r);
    ctx.fillStyle = COLORS.paddle;
    ctx.fill();
    ctx.closePath();
}

function drawBricks() {
    for(let c=0; c<BRICK_COLS; c++) {
        for(let r=0; r<BRICK_ROWS; r++) {
            if(bricks[c][r].status === 1) {
                const brickX = (c*(BRICK_WIDTH+BRICK_PADDING)) + BRICK_OFFSET_LEFT;
                const brickY = (r*(BRICK_HEIGHT+BRICK_PADDING)) + BRICK_OFFSET_TOP;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                
                ctx.beginPath();
                ctx.roundRect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT, 4);
                ctx.fillStyle = bricks[c][r].color;
                ctx.fill();
                ctx.closePath();
            }
        }
    }
}

function drawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].draw(ctx);
        if (!particles[i].update()) {
            particles.splice(i, 1);
        }
    }
}

function collisionDetection() {
    for(let c=0; c<BRICK_COLS; c++) {
        for(let r=0; r<BRICK_ROWS; r++) {
            const b = bricks[c][r];
            if(b.status === 1) {
                // Simple AABB collision
                if(ball.x > b.x && ball.x < b.x + BRICK_WIDTH && ball.y > b.y && ball.y < b.y + BRICK_HEIGHT) {
                    ball.dy = -ball.dy;
                    b.status = 0;
                    score++;
                    document.getElementById('score-val').innerText = score;
                    soundManager.playBrickHit();
                    if(navigator.vibrate) navigator.vibrate(10); // Haptic light

                    // Create explosion
                    for (let i=0; i<8; i++) {
                        particles.push(new Particle(ball.x, ball.y, b.color));
                    }

                    // Check win
                    if(score === BRICK_ROWS*BRICK_COLS) {
                        gameOver(true);
                    }
                }
            }
        }
    }
}

function update() {
    if (gameState !== 'PLAYING') return;

    // Clear Canvas
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    drawBricks();
    drawBall();
    drawPaddle();
    drawParticles();
    collisionDetection();

    // Wall Collision
    if(ball.x + ball.dx > GAME_WIDTH - BALL_RADIUS || ball.x + ball.dx < BALL_RADIUS) {
        ball.dx = -ball.dx;
        soundManager.playBounce();
    }
    if(ball.y + ball.dy < BALL_RADIUS) {
        ball.dy = -ball.dy;
        soundManager.playBounce();
    } else if(ball.y + ball.dy > GAME_HEIGHT - BALL_RADIUS - 10) {
        // Paddle Collision (Advanced Physics)
        if(ball.x > PADDLE_X && ball.x < PADDLE_X + PADDLE_WIDTH) {
            
            // Calculate hit point relative to center (-1 to 1)
            let collidePoint = ball.x - (PADDLE_X + PADDLE_WIDTH/2);
            collidePoint = collidePoint / (PADDLE_WIDTH/2);
            
            // Convert to angle (max 60 degrees)
            const angle = collidePoint * (Math.PI/3);
            
            // Calculate new velocity vectors based on speed conservation
            // Slight speed increase on every paddle hit
            ball.speed = Math.min(ball.speed * 1.02, GAME_HEIGHT * 0.015);
            
            ball.dx = ball.speed * Math.sin(angle);
            ball.dy = -ball.speed * Math.cos(angle);

            soundManager.playPaddleHit();
            if(navigator.vibrate) navigator.vibrate(15);
        } else if (ball.y > GAME_HEIGHT) {
            // Ball lost
            gameOver(false);
            return;
        }
    }

    ball.x += ball.dx;
    ball.y += ball.dy;

    animationId = requestAnimationFrame(update);
}

function gameOver(win) {
    gameState = win ? 'WON' : 'GAMEOVER';
    cancelAnimationFrame(animationId);
    
    const overlay = document.getElementById('menu-overlay');
    const title = document.getElementById('menu-title');
    const desc = document.getElementById('menu-desc');
    const btn = document.getElementById('btn-start');

    overlay.classList.remove('hidden');
    
    if (win) {
        title.innerText = "You Win! üéâ";
        title.style.color = COLORS.paddle;
        soundManager.playWin();
    } else {
        title.innerText = "Game Over";
        title.style.color = "var(--md-sys-color-error)";
        soundManager.playGameOver();
    }
    
    desc.innerHTML = `ÊúÄÁªàÂæóÂàÜ: ${score}`;
    btn.innerText = "ÂÜçÁé©‰∏ÄÊ¨°";
}

function startGame() {
    score = 0;
    document.getElementById('score-val').innerText = '0';
    gameState = 'PLAYING';
    document.getElementById('menu-overlay').classList.add('hidden');
    
    initBricks();
    resetBallPaddle();
    
    // Ensure AudioContext is running (requires user interaction)
    if (soundManager.ctx.state === 'suspended') {
        soundManager.ctx.resume();
    }

    update();
}

// UI Event Listeners
document.getElementById('btn-start').addEventListener('click', startGame);

const btnSound = document.getElementById('btn-sound');
btnSound.addEventListener('click', () => {
    const isOn = soundManager.toggle();
    document.getElementById('icon-sound-on').style.display = isOn ? 'block' : 'none';
    document.getElementById('icon-sound-off').style.display = isOn ? 'none' : 'block';
});

// Window resize listener
window.addEventListener('resize', () => {
    resize();
    drawPaddle();
    drawBricks();
    drawBall();
});

// Initial Setup
resize();
drawPaddle(); // Draw static preview
drawBall();

</script>
</body>
</html>

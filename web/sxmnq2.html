<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>沙箱模拟器 2</title>
    <style>
        /* --- Material Design 3 风格变量 --- */
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;
            --md-sys-color-surface: #FEF7FF;
            --md-sys-color-surface-container: #F3EDF7;
            --md-sys-color-outline: #79747E;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-full: 9999px;
            --font-family: 'Roboto', sans-serif;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--md-sys-color-surface);
            font-family: var(--font-family);
            color: #1D1B20;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 禁止页面滚动 */
        }

        /* --- 顶部标题栏 --- */
        header {
            padding: 16px;
            background: var(--md-sys-color-surface-container);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 500;
        }

        /* --- 游戏区域 (Canvas) --- */
        #game-container {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none; /* 关键：禁止触摸时的浏览器默认行为 */
        }

        canvas {
            image-rendering: pixelated; /* 保持像素清晰 */
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* --- 底部控制栏 --- */
        .controls-wrapper {
            background: var(--md-sys-color-surface-container);
            padding: 12px 16px;
            border-top-left-radius: 24px;
            border-top-right-radius: 24px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 10;
        }

        /* 元素选择滚动条 */
        .element-scroll {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
            scrollbar-width: none; /* Firefox */
        }
        .element-scroll::-webkit-scrollbar { display: none; }

        .element-btn {
            flex: 0 0 auto;
            padding: 8px 16px;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--radius-lg);
            background: transparent;
            color: #1D1B20;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .element-btn.active {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-color: transparent;
        }
        
        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
        }

        /* 操作按钮行 */
        .action-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .icon-btn {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            width: 48px;
            height: 48px;
            border-radius: var(--radius-full);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transition: transform 0.1s;
        }

        .icon-btn:active {
            transform: scale(0.95);
        }

        .secondary-actions {
            display: flex;
            gap: 8px;
        }

        .text-btn {
            background: transparent;
            border: none;
            color: var(--md-sys-color-primary);
            font-weight: 500;
            padding: 8px 12px;
            font-size: 14px;
        }

        /* Toast 提示 */
        #toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <header>
        <h1>沙箱模拟器 2</h1>
        <div id="fps-counter" style="font-size: 12px; opacity: 0.6;">FPS: 60</div>
    </header>

    <div id="game-container">
        <canvas id="sandbox"></canvas>
    </div>

    <div class="controls-wrapper">
        <!-- 元素选择器 -->
        <div class="element-scroll" id="element-list">
            <!-- JS 动态生成 -->
        </div>

        <!-- 底部控制按钮 -->
        <div class="action-row">
            <div class="secondary-actions">
                <button class="text-btn" onclick="saveGame()">保存</button>
                <button class="text-btn" onclick="loadGame()">读取</button>
                <button class="text-btn" onclick="clearCanvas()" style="color:#B3261E;">清空</button>
            </div>
            
            <button class="icon-btn" id="play-pause-btn" onclick="togglePause()">
                ⏸
            </button>
        </div>
    </div>

    <div id="toast">提示信息</div>

    <script>
        // ==========================================
        // 1. 配置区域：二创可以在这里添加新元素
        // ==========================================
        const ELEMENT_TYPES = {
            EMPTY: { id: 0, name: "橡皮", color: "#000000", type: "empty" },
            SAND:  { id: 1, name: "沙子", color: "#E6C229", type: "powder", density: 10 },
            STONE: { id: 2, name: "石头", color: "#7D7D7D", type: "static" },
            WATER: { id: 3, name: "水",   color: "#00A8FF", type: "liquid", density: 5, dispersion: 5 },
            WOOD:  { id: 4, name: "木头", color: "#8B4513", type: "static", flammable: true, burnChance: 0.05 },
            FIRE:  { id: 5, name: "火",   color: "#FF4500", type: "gas", life: 30 },
            SMOKE: { id: 6, name: "烟",   color: "#555555", type: "gas", life: 80 },
            PLANT: { id: 7, name: "植物", color: "#2ECC71", type: "static", flammable: true, burnChance: 0.1 },
            ACID:  { id: 8, name: "酸",   color: "#C1FF00", type: "liquid", density: 4, corrosive: true },
            TNT:   { id: 9, name: "炸药", color: "#E74C3C", type: "static", explosive: true }
        };

        // 画笔大小
        const BRUSH_SIZE = 2; // 半径
        // 模拟分辨率缩放 (值越小像素越多，100-150 是移动端性能甜点)
        const SIM_WIDTH = 120; 
        let SIM_HEIGHT = 0; // 根据屏幕比例计算

        // ==========================================
        // 2. 核心变量初始化
        // ==========================================
        const canvas = document.getElementById('sandbox');
        const ctx = canvas.getContext('2d', { alpha: false }); // 优化性能
        const playPauseBtn = document.getElementById('play-pause-btn');
        const fpsCounter = document.getElementById('fps-counter');

        let grid = []; // 存储当前的像素 ID
        let pixelData = null; // Canvas 图像数据
        let isPaused = false;
        let currentElement = ELEMENT_TYPES.SAND;
        let isDrawing = false;
        let lastTouchX = 0, lastTouchY = 0;
        let animationFrameId;

        // ==========================================
        // 3. 系统初始化与 UI 生成
        // ==========================================
        function init() {
            // 计算画布大小
            const container = document.getElementById('game-container');
            const ratio = container.clientHeight / container.clientWidth;
            SIM_HEIGHT = Math.floor(SIM_WIDTH * ratio);

            canvas.width = SIM_WIDTH;
            canvas.height = SIM_HEIGHT;

            // 初始化网格
            grid = new Array(SIM_WIDTH * SIM_HEIGHT).fill(0);
            pixelData = ctx.createImageData(SIM_WIDTH, SIM_HEIGHT);

            // 生成 UI 按钮
            const scrollContainer = document.getElementById('element-list');
            Object.values(ELEMENT_TYPES).forEach(elem => {
                const btn = document.createElement('button');
                btn.className = 'element-btn';
                if(elem.id === 1) btn.classList.add('active'); // 默认选中沙子
                btn.innerHTML = `<span class="color-dot" style="background:${elem.color}"></span>${elem.name}`;
                btn.onclick = () => selectElement(elem, btn);
                scrollContainer.appendChild(btn);
            });

            // 启动循环
            update();
        }

        function selectElement(elem, btn) {
            currentElement = elem;
            document.querySelectorAll('.element-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        // ==========================================
        // 4. 输入处理 (鼠标 & 触摸)
        // ==========================================
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: Math.floor((clientX - rect.left) * scaleX),
                y: Math.floor((clientY - rect.top) * scaleY)
            };
        }

        function drawAt(cx, cy) {
            for (let y = -BRUSH_SIZE; y <= BRUSH_SIZE; y++) {
                for (let x = -BRUSH_SIZE; x <= BRUSH_SIZE; x++) {
                    if (x*x + y*y <= BRUSH_SIZE*BRUSH_SIZE) {
                        setCell(cx + x, cy + y, currentElement.id);
                        // 稍微加点随机性，让自然元素看起来更自然
                        if (Math.random() > 0.8 && currentElement.id !== 0) {
                            setCell(cx + x + (Math.random()>0.5?1:-1), cy + y, currentElement.id);
                        }
                    }
                }
            }
        }

        function handleInputStart(e) {
            isDrawing = true;
            const {x, y} = getCoords(e);
            drawAt(x, y);
            lastTouchX = x; lastTouchY = y;
        }

        function handleInputMove(e) {
            if (!isDrawing) return;
            const {x, y} = getCoords(e);
            
            // 简单的插值算法，防止画得太快出现断层
            const dist = Math.hypot(x - lastTouchX, y - lastTouchY);
            const steps = Math.ceil(dist);
            for(let i=0; i<steps; i++) {
                const tx = lastTouchX + (x - lastTouchX) * (i/steps);
                const ty = lastTouchY + (y - lastTouchY) * (i/steps);
                drawAt(Math.floor(tx), Math.floor(ty));
            }
            
            lastTouchX = x; lastTouchY = y;
        }

        canvas.addEventListener('mousedown', handleInputStart);
        canvas.addEventListener('mousemove', handleInputMove);
        window.addEventListener('mouseup', () => isDrawing = false);

        canvas.addEventListener('touchstart', handleInputStart, {passive: false});
        canvas.addEventListener('touchmove', handleInputMove, {passive: false});
        window.addEventListener('touchend', () => isDrawing = false);

        // ==========================================
        // 5. 物理引擎核心 (更新逻辑)
        // ==========================================
        
        // 工具函数
        const getIdx = (x, y) => x + y * SIM_WIDTH;
        const isEmpty = (idx) => grid[idx] === 0;
        const inBounds = (x, y) => x >= 0 && x < SIM_WIDTH && y >= 0 && y < SIM_HEIGHT;
        const getType = (id) => Object.values(ELEMENT_TYPES).find(e => e.id === id);

        function setCell(x, y, id) {
            if (inBounds(x, y)) {
                grid[getIdx(x, y)] = id;
            }
        }

        function update() {
            if (!isPaused) {
                // 从下往上遍历（为了模拟重力）
                // 使用修改后的网格副本来避免同一帧移动多次（简单起见，这里直接用随机方向遍历或反向遍历）
                // 经典的沙箱通常需要从下往上遍历以处理坠落
                
                // 我们使用一个简单的脏标记或直接修改。为了简单且快，我们在同一数组操作，但要小心顺序。
                // 液体和粉末从下往上扫描。
                
                // 复制一份当前状态用于逻辑判断，写入到 grid (或者反过来，这里为了极高性能直接原地操作，但需注意顺序)
                // 原地操作：从底向上，从左到右或右到左随机
                
                for (let y = SIM_HEIGHT - 1; y >= 0; y--) {
                    // 随机左右遍历顺序，防止倾向性堆积
                    const ltr = Math.random() > 0.5;
                    for (let i = 0; i < SIM_WIDTH; i++) {
                        const x = ltr ? i : (SIM_WIDTH - 1 - i);
                        const idx = getIdx(x, y);
                        const cellId = grid[idx];

                        if (cellId === 0) continue;

                        const typeConfig = getType(cellId);
                        if (!typeConfig) continue;

                        // --- 行为逻辑 ---

                        // 1. 气体 (GAS): 向上飘
                        if (typeConfig.type === 'gas') {
                            // 随机消失
                            if (typeConfig.life && Math.random() < 0.05) {
                                grid[idx] = 0; // 消失
                                continue;
                            }
                            
                            let moved = false;
                            // 尝试向上
                            if (inBounds(x, y-1) && isEmpty(getIdx(x, y-1))) {
                                grid[idx] = 0; grid[getIdx(x, y-1)] = cellId; moved = true;
                            } 
                            // 尝试左上/右上
                            else if (inBounds(x-1, y-1) && isEmpty(getIdx(x-1, y-1)) && Math.random()>0.5) {
                                grid[idx] = 0; grid[getIdx(x-1, y-1)] = cellId; moved = true;
                            }
                            else if (inBounds(x+1, y-1) && isEmpty(getIdx(x+1, y-1)) && Math.random()>0.5) {
                                grid[idx] = 0; grid[getIdx(x+1, y-1)] = cellId; moved = true;
                            }
                        }

                        // 2. 粉末 (POWDER): 向下，斜向
                        else if (typeConfig.type === 'powder') {
                            let below = getIdx(x, y + 1);
                            let belowLeft = getIdx(x - 1, y + 1);
                            let belowRight = getIdx(x + 1, y + 1);
                            
                            // 尝试向下
                            if (inBounds(x, y+1)) {
                                if (isEmpty(below) || getType(grid[below]).type === 'liquid' || getType(grid[below]).type === 'gas') {
                                    // 交换 (下落或沉入液体)
                                    let targetId = grid[below];
                                    grid[below] = cellId;
                                    grid[idx] = targetId; 
                                    continue;
                                }
                                // 尝试斜向
                                let dir = Math.random() > 0.5 ? -1 : 1;
                                if (inBounds(x + dir, y + 1) && isEmpty(getIdx(x + dir, y + 1))) {
                                    grid[idx] = 0;
                                    grid[getIdx(x + dir, y + 1)] = cellId;
                                    continue;
                                }
                            }
                        }

                        // 3. 液体 (LIQUID): 向下，向四周流
                        else if (typeConfig.type === 'liquid') {
                            let below = getIdx(x, y + 1);
                            
                            // 下落
                            if (inBounds(x, y + 1) && isEmpty(below)) {
                                grid[below] = cellId;
                                grid[idx] = 0;
                                continue;
                            }
                            
                            // 左右流淌
                            let dir = Math.random() > 0.5 ? 1 : -1;
                            let newX = x + dir;
                            if (inBounds(newX, y) && isEmpty(getIdx(newX, y))) {
                                grid[getIdx(newX, y)] = cellId;
                                grid[idx] = 0;
                                continue;
                            }
                        }

                        // --- 交互反应 ---

                        // 火烧木头/植物
                        if (typeConfig.id === ELEMENT_TYPES.FIRE.id) {
                            for(let dx=-1; dx<=1; dx++) {
                                for(let dy=-1; dy<=1; dy++) {
                                    if(!inBounds(x+dx, y+dy)) continue;
                                    let nIdx = getIdx(x+dx, y+dy);
                                    let neighbor = getType(grid[nIdx]);
                                    if(neighbor && neighbor.flammable) {
                                        if(Math.random() < neighbor.burnChance) {
                                            grid[nIdx] = ELEMENT_TYPES.FIRE.id; // 点燃
                                            // 产生烟
                                            if(inBounds(x, y-1) && isEmpty(getIdx(x,y-1))) {
                                                grid[getIdx(x, y-1)] = ELEMENT_TYPES.SMOKE.id;
                                            }
                                        }
                                    }
                                    // 炸药
                                    if(neighbor && neighbor.explosive) {
                                        explode(x+dx, y+dy);
                                    }
                                }
                            }
                        }

                        // 酸腐蚀
                        if (typeConfig.corrosive) {
                             let dir = Math.random() > 0.5 ? 1 : -1; // 随机检查下方或侧面
                             let tx = x, ty = y+1;
                             if (!inBounds(tx, ty)) continue;
                             
                             let targetId = grid[getIdx(tx, ty)];
                             if (targetId !== 0 && targetId !== cellId && targetId !== ELEMENT_TYPES.ACID.id) {
                                 if (Math.random() < 0.1) {
                                     grid[getIdx(tx, ty)] = 0; // 溶解
                                     grid[idx] = 0; // 酸也被消耗
                                     // 产生一点烟
                                     if(inBounds(x, y-1)) grid[getIdx(x, y-1)] = ELEMENT_TYPES.SMOKE.id;
                                 }
                             }
                        }
                    }
                }
            }
            
            draw();
            animationFrameId = requestAnimationFrame(update);
            updateFPS();
        }

        function explode(cx, cy) {
            const radius = 8;
            for(let y = -radius; y <= radius; y++) {
                for(let x = -radius; x <= radius; x++) {
                    if (x*x + y*y <= radius*radius) {
                        let tx = cx + x;
                        let ty = cy + y;
                        if(inBounds(tx, ty)) {
                            grid[getIdx(tx, ty)] = (Math.random() > 0.3) ? ELEMENT_TYPES.FIRE.id : ELEMENT_TYPES.SMOKE.id;
                            if(Math.random() > 0.8) grid[getIdx(tx, ty)] = 0; // 空洞
                        }
                    }
                }
            }
        }

        // ==========================================
        // 6. 渲染逻辑
        // ==========================================
        function draw() {
            // 直接操作 ImageData 缓冲区，比 fillRect 快得多
            const data = pixelData.data;
            const bgR = 0, bgG = 0, bgB = 0; // 背景黑

            for (let i = 0; i < grid.length; i++) {
                const id = grid[i];
                const idx = i * 4;
                
                if (id === 0) {
                    data[idx] = bgR; data[idx+1] = bgG; data[idx+2] = bgB; data[idx+3] = 255;
                } else {
                    const colorHex = getType(id).color;
                    // 简单的 HEX 转 RGB 缓存可以优化这里，但为了代码简洁直接转
                    // 使用 parseInt 解析
                    const r = parseInt(colorHex.slice(1, 3), 16);
                    const g = parseInt(colorHex.slice(3, 5), 16);
                    const b = parseInt(colorHex.slice(5, 7), 16);

                    // 给一点颜色抖动让画面更有质感
                    const noise = (Math.random() - 0.5) * 20;
                    
                    data[idx] = r + noise;
                    data[idx+1] = g + noise;
                    data[idx+2] = b + noise;
                    data[idx+3] = 255;
                }
            }
            ctx.putImageData(pixelData, 0, 0);
        }

        // ==========================================
        // 7. 功能控制 (暂停、保存、读取)
        // ==========================================
        function togglePause() {
            isPaused = !isPaused;
            playPauseBtn.innerText = isPaused ? '▶' : '⏸';
            showToast(isPaused ? "已暂停" : "继续模拟");
        }

        function clearCanvas() {
            if(confirm('确定要清空画布吗？')) {
                grid.fill(0);
                showToast("画布已清空");
            }
        }

        function saveGame() {
            try {
                // RLE 压缩或直接存 JSON (JSON 对大数组较慢，但对于 120xHeight 还可以接受)
                // 为防止 LocalStorage溢出，我们只存非空数据或者简单压缩
                const saveData = JSON.stringify(grid);
                localStorage.setItem('sandbox_save_1', saveData);
                showToast("存档已保存！");
            } catch (e) {
                console.error(e);
                showToast("保存失败：空间不足？");
            }
        }

        function loadGame() {
            const data = localStorage.getItem('sandbox_save_1');
            if (data) {
                try {
                    const loadedGrid = JSON.parse(data);
                    if (loadedGrid.length === grid.length) {
                        grid = loadedGrid;
                        showToast("存档读取成功！");
                    } else {
                        showToast("存档版本不匹配");
                    }
                } catch (e) {
                    showToast("存档损坏");
                }
            } else {
                showToast("没有找到存档");
            }
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 2000);
        }

        // FPS 计算
        let lastTime = performance.now();
        let frameCount = 0;
        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fpsCounter.innerText = `FPS: ${frameCount}`;
                frameCount = 0;
                lastTime = now;
            }
        }

        // 启动
        window.onload = init;

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MD3 Áâ©ÁêÜÊ≤ôÁõò (Max Ultra Pro)</title>
    
    <!-- Âä®ÊÄÅÊ†∑ÂºèÈìæÊé• ID -->
    <link id="icon-css-link" href="https://cdn.jsdelivr.net/npm/@mdi/font@6.x/css/materialdesignicons.min.css" rel="stylesheet">
    <!-- Vuetify CSS -->
    <link href="https://cdn.jsdelivr.net/npm/vuetify@3.4.0/dist/vuetify.min.css" rel="stylesheet">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
            touch-action: none;
            font-family: 'Roboto', sans-serif;
        }
        
        /* --- Âä†ËΩΩÂ±èÂπï (Â±Ö‰∏≠„ÄÅÂªâ‰ª∑ÊÑü) --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111; 
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            transition: opacity 0.5s ease;
        }
        
        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .loading-logo {
            font-size: 64px;
            color: #444; 
            margin-bottom: 20px;
            line-height: 1;
        }

        .loading-title {
            color: #eee; 
            margin-bottom: 30px; 
            font-weight: 400; 
            font-size: 20px;
            font-family: monospace; 
        }

        .loading-spinner {
            width: 30px;
            height: 30px;
            border: 4px solid #333; 
            border-radius: 50%;
            border-top-color: #fff; 
            animation: spin 1s steps(12) infinite; 
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Ê∏∏ÊàèÁîªÂ∏É --- */
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        /* --- UI ÁªìÊûÑ --- */
        .ui-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50; 
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            padding: 12px;
            padding-top: max(12px, env(safe-area-inset-top));
            display: flex;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .top-right-controls {
            position: absolute;
            top: 0;
            right: 0;
            padding: 12px;
            padding-top: max(12px, env(safe-area-inset-top));
            display: flex;
            flex-direction: column; 
            gap: 12px;
            pointer-events: auto;
            z-index: 20; 
        }

        .ui-controls-container {
            width: 100%;
            pointer-events: auto;
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            will-change: transform;
        }

        .ui-controls-container.closed {
            transform: translateY(110%);
        }

        .ui-controls {
            background: rgba(20, 20, 23, 0.97); 
            border-top-left-radius: 32px;
            border-top-right-radius: 32px;
            padding: 0; 
            padding-bottom: max(24px, env(safe-area-inset-bottom));
            backdrop-filter: blur(30px);
            box-shadow: 0 -10px 60px rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            border-top: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
        }

        /* ÂìÅÁâåÊ†áÈ¢òÊ†è */
        .brand-header {
            width: 100%;
            padding: 12px 0;
            text-align: center;
            background: rgba(255,255,255,0.03);
            border-bottom: 1px solid rgba(255,255,255,0.05);
            margin-bottom: 16px;
        }
        .brand-title {
            font-size: 10px;
            font-weight: 900;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.3);
            text-transform: uppercase;
        }

        .controls-content {
            padding: 0 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .element-btn {
            text-transform: none !important;
            font-weight: 700;
            letter-spacing: 0.5px;
            border-width: 1px;
        }

        .grid-elements {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(78px, 1fr));
            gap: 8px;
            max-height: 45vh;
            overflow-y: auto;
            padding: 4px;
            scroll-behavior: smooth;
            overscroll-behavior-y: contain; 
            -webkit-overflow-scrolling: touch;
        }
        
        .grid-elements::-webkit-scrollbar { width: 3px; }
        .grid-elements::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

        .top-btn { pointer-events: auto; }
        
        /* ÂÖºÂÆπ‰∏çÂêåÂõæÊ†áÂ∫ìÁöÑÈÄöÁî®Ê†∑Âºè */
        .custom-icon {
            font-size: 18px;
            line-height: 1;
            display: inline-block;
        }
        .bi { font-style: normal; }

        /* ‰∏ì‰∏öÊ®°ÂºèÊï∞ÊçÆÊ†∑Âºè */
        .pro-hud {
            font-family: 'Courier New', Courier, monospace;
            font-size: 11px;
            line-height: 1.2;
            white-space: pre;
        }
    </style>
</head>
<body>

    <!-- 1. Âä†ËΩΩÂ±èÂπï -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="mdi mdi-cube-outline loading-logo"></div>
            <div class="loading-title">PHYSICS_ENGINE_V5</div>
            <div class="loading-spinner"></div>
        </div>
    </div>

    <div id="app">
        <v-app theme="dark" style="background: transparent;">
            <!-- ÁîªÂ∏É -->
            <canvas id="game-canvas" ref="canvasRef"></canvas>

            <!-- È°∂ÈÉ®Â∑¶‰æßÔºöHUD‰ø°ÊÅØÁõëÊéß (Ê†πÊçÆÊ®°ÂºèÂèòÂåñ) -->
            <div class="top-bar">
                <v-chip class="top-btn" color="surface-variant" label size="small" style="opacity: 0.9;">
                    <v-icon start icon="mdi-monitor-dashboard" size="small"></v-icon>
                    
                    <!-- ÁÆÄÊ¥ÅÊ®°Âºè -->
                    <span v-if="hudMode === 'simple'" style="font-family: monospace; font-weight: bold;">
                        FPS: {{ fps }}
                    </span>

                    <!-- ‰∏≠Á≠âÊ®°Âºè -->
                    <span v-else-if="hudMode === 'medium'" style="font-family: monospace;">
                        FPS: {{ fps }} | Á≤íÂ≠ê: {{ particleCount }}
                    </span>

                    <!-- ‰∏ì‰∏öÊ®°Âºè -->
                    <span v-else class="pro-hud">
                        FPS:{{fps}} | P:{{particleCount}} | RES:{{resolutionSetting}} | G:{{width}}x{{height}} | B:{{brushSize}}
                    </span>
                </v-chip>
            </div>

            <!-- È°∂ÈÉ®Âè≥‰æßÊéßÂà∂ -->
            <div class="top-right-controls">
                <v-btn icon :color="isMenuOpen ? 'primary' : 'surface-variant'" variant="flat" @click="toggleMenu" elevation="4" size="default">
                    <v-icon :icon="isMenuOpen ? 'mdi-chevron-down' : 'mdi-menu'"></v-icon>
                </v-btn>
                <v-btn icon="mdi-cog" variant="tonal" size="small" color="default" @click="settingsDialog = true"></v-btn>
                <v-btn icon size="small" :color="isPaused ? 'warning' : 'default'" @click="togglePause" variant="tonal">
                    <v-icon>{{ isPaused ? 'mdi-play' : 'mdi-pause' }}</v-icon>
                </v-btn>
                <v-btn icon size="small" color="error" @click="clearCanvas" variant="tonal">
                    <v-icon>mdi-delete-sweep</v-icon>
                </v-btn>
            </div>

            <!-- ËÆæÁΩÆÂºπÁ™ó -->
            <v-dialog v-model="settingsDialog" max-width="420" transition="dialog-bottom-transition">
                <v-card theme="dark" class="rounded-xl">
                    <v-card-title class="d-flex align-center pt-4">
                        <v-icon icon="mdi-cog" class="mr-2" color="primary"></v-icon>
                        Á≥ªÁªüËÆæÁΩÆ
                    </v-card-title>
                    <v-card-text>
                        <!-- HUD Ê®°ÂºèÂàáÊç¢ -->
                        <div class="text-subtitle-2 mb-2 text-primary font-weight-bold">Â∑¶‰∏äËßíÁõëÊéß‰ø°ÊÅØ</div>
                        <v-btn-toggle
                            v-model="hudMode"
                            mandatory
                            color="primary"
                            variant="outlined"
                            density="compact"
                            class="mb-4 w-100"
                            divided
                        >
                            <v-btn value="simple" class="flex-grow-1">ÁÆÄÊ¥Å</v-btn>
                            <v-btn value="medium" class="flex-grow-1">‰∏≠Á≠â</v-btn>
                            <v-btn value="pro" class="flex-grow-1">‰∏ì‰∏ö</v-btn>
                        </v-btn-toggle>

                        <v-divider class="mb-4"></v-divider>

                        <!-- ÂõæÊ†áÊ†∑ÂºèÂàáÊç¢ -->
                        <div class="text-subtitle-2 mb-2 text-primary font-weight-bold">ÂõæÊ†áÊ†∑ÂºèÂ∫ì</div>
                        <v-select
                            v-model="iconSourceType"
                            :items="iconSources"
                            item-title="name"
                            item-value="value"
                            variant="outlined"
                            density="compact"
                            hide-details
                            class="mb-4"
                            prepend-inner-icon="mdi-shape"
                            @update:model-value="changeIconSource"
                        >
                            <template v-slot:item="{ props, item }">
                                <v-list-item v-bind="props" :subtitle="item.raw.desc"></v-list-item>
                            </template>
                        </v-select>

                        <v-divider class="mb-4"></v-divider>

                        <div class="text-subtitle-2 mb-2 text-primary font-weight-bold">Ê∏≤ÊüìÁ≤æÂ∫¶</div>
                        <div class="d-flex align-center">
                            <v-icon icon="mdi-blur" size="small" class="mr-3"></v-icon>
                            <v-slider
                                v-model="resolutionSetting"
                                min="1"
                                max="10"
                                step="1"
                                color="primary"
                                track-color="surface-variant"
                                thumb-label="always"
                                hide-details
                            ></v-slider>
                        </div>
                    </v-card-text>
                    <v-card-actions class="pb-4 pr-4">
                        <v-spacer></v-spacer>
                        <v-btn color="primary" variant="tonal" @click="settingsDialog = false">ÂÆåÊàê</v-btn>
                    </v-card-actions>
                </v-card>
            </v-dialog>

            <!-- Â∫ïÈÉ®Èù¢Êùø -->
            <div class="ui-overlay">
                <div class="ui-controls-container" :class="{ 'closed': !isMenuOpen }">
                    <div class="ui-controls">
                        <!-- ÂìÅÁâå Header -->
                        <div class="brand-header">
                            <div class="brand-title">Physics Sandbox Engine /// v5.0</div>
                        </div>

                        <div class="controls-content">
                            <!-- ÁîªÁ¨î -->
                            <div class="d-flex align-center">
                                <v-btn-toggle v-model="brushShape" density="compact" color="primary" mandatory class="mr-4" rounded="xl" variant="outlined" divided>
                                    <v-btn value="circle" icon="mdi-circle"></v-btn>
                                    <v-btn value="square" icon="mdi-square"></v-btn>
                                </v-btn-toggle>
                                
                                <v-icon icon="mdi-brush" size="small" class="mr-3 text-disabled"></v-icon>
                                <v-slider
                                    v-model="brushSize"
                                    min="1"
                                    max="50"
                                    step="1"
                                    hide-details
                                    thumb-label
                                    color="primary"
                                    track-color="surface-variant"
                                ></v-slider>
                            </div>

                            <!-- Âø´Êç∑Ê†è -->
                            <div class="d-flex align-center">
                                <v-slide-group show-arrows center-active mandatory v-model="selectedElementId" class="flex-grow-1">
                                    <v-slide-group-item
                                        v-for="el in shortcutElements"
                                        :key="el.id"
                                        v-slot="{ isSelected, toggle }"
                                        :value="el.id"
                                    >
                                        <v-btn
                                            class="element-btn mx-1"
                                            :color="isSelected ? el.uiColor : 'surface-variant'"
                                            :variant="isSelected ? 'flat' : 'text'"
                                            rounded="pill"
                                            @click="toggle"
                                            height="44"
                                            border
                                        >
                                            <v-icon v-if="iconSourceType === 'mdi' || iconSourceType === 'mdi-mirror'" start size="small" :icon="el.mdi" :color="isSelected ? '' : el.uiColor"></v-icon>
                                            <i v-else-if="iconSourceType === 'bootstrap'" class="mr-2 custom-icon" :class="el.bi"></i>
                                            <span v-else class="mr-2 custom-icon">{{ el.emoji }}</span>
                                            
                                            {{ el.name }}
                                        </v-btn>
                                    </v-slide-group-item>
                                </v-slide-group>

                                <v-btn icon="mdi-view-grid-plus" variant="tonal" class="ml-2" @click="showMoreMenu = !showMoreMenu" color="secondary" rounded="lg">
                                </v-btn>
                            </div>

                            <!-- Êõ¥Â§öÁΩëÊ†º -->
                            <v-expand-transition>
                                <div v-if="showMoreMenu" class="mt-2">
                                    <div class="text-caption text-medium-emphasis mb-2 ml-1 font-weight-bold">ELEMENT LIBRARY</div>
                                    <div class="grid-elements">
                                        <v-btn
                                            v-for="el in allElements"
                                            :key="el.id"
                                            class="element-btn"
                                            :color="selectedElementId === el.id ? el.uiColor : 'surface-variant'"
                                            :variant="selectedElementId === el.id ? 'flat' : 'tonal'"
                                            rounded="lg"
                                            height="64"
                                            stacked
                                            @click="selectFromMore(el)"
                                        >
                                            <v-icon v-if="iconSourceType === 'mdi' || iconSourceType === 'mdi-mirror'" :icon="el.mdi" class="mb-1" :color="selectedElementId === el.id ? '' : el.uiColor"></v-icon>
                                            <i v-else-if="iconSourceType === 'bootstrap'" class="mb-1 custom-icon" :class="el.bi" style="font-size:20px;"></i>
                                            <span v-else class="mb-1 custom-icon" style="font-size: 24px;">{{ el.emoji }}</span>
                                            
                                            <span style="font-size: 10px; opacity: 0.8;">{{ el.name }}</span>
                                        </v-btn>
                                    </div>
                                </div>
                            </v-expand-transition>
                        </div>
                    </div>
                </div>
            </div>
        </v-app>
    </div>

    <!-- ËÑöÊú¨ -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@3.4.0/dist/vuetify.min.js"></script>

    <script>
        const { createApp, ref, onMounted, computed, watch, nextTick } = Vue;
        const { createVuetify } = Vuetify;

        const vuetify = createVuetify();

        const app = createApp({
            setup() {
                // --- Áä∂ÊÄÅÁÆ°ÁêÜ ---
                const canvasRef = ref(null);
                const fps = ref(0);
                const particleCount = ref(0);
                const isPaused = ref(false);
                const brushSize = ref(6);
                const brushShape = ref('circle');
                const isMenuOpen = ref(true);
                const showMoreMenu = ref(false);
                const settingsDialog = ref(false);
                const resolutionSetting = ref(6); 
                const hudMode = ref('medium'); // HUD Ê®°ÂºèÔºösimple, medium, pro
                
                // ÂõæÊ†áÊ∫êÊéßÂà∂
                const iconSourceType = ref('mdi');
                const iconSources = [
                    { name: 'Standard (MDI)', value: 'mdi', desc: 'Material Design Icons', url: 'https://cdn.jsdelivr.net/npm/@mdi/font@6.x/css/materialdesignicons.min.css' },
                    { name: 'Mirror (MDI CN)', value: 'mdi-mirror', desc: 'ÂõΩÂÜÖ‰∏ÉÁâõ‰∫ëÈïúÂÉè', url: 'https://cdn.staticfile.org/MaterialDesign-Icons/6.5.95/css/materialdesignicons.min.css' },
                    { name: 'Bootstrap Icons', value: 'bootstrap', desc: 'ÂÆåÂÖ®‰∏çÂêåÁöÑÊ†∑ÂºèÂ∫ì', url: 'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css' },
                    { name: 'Emoji Mode', value: 'emoji', desc: 'Êó†ÈúÄÁΩëÁªú', url: '' }
                ];

                const changeIconSource = (val) => {
                    const selected = iconSources.find(s => s.value === val);
                    const linkEl = document.getElementById('icon-css-link');
                    if (val === 'emoji') {
                        // EmojiÊ®°Âºè
                    } else if (linkEl && selected.url) {
                        linkEl.href = selected.url;
                    }
                };

                const TYPES = {
                    EMPTY: 0, SAND: 1, WATER: 2, STONE: 3, FIRE: 4, 
                    ACID: 5, WOOD: 6, OIL: 7, PLANT: 8, GUNPOWDER: 9, 
                    STEAM: 10, ICE: 11, METHANE: 12, WAX: 13,
                    C4: 14, NITROGEN: 15, VIRUS: 16,
                    TERMITE: 17, FUSE: 18, THUNDER: 19,
                    MERCURY: 20, URANIUM: 21,
                    SALT: 22, CONCRETE: 23, PLASMA: 24,
                    LAVA: 25, CLOUD: 26, VOID: 27 // Êñ∞Â¢ûÔºöÂ≤©ÊµÜ„ÄÅ‰∫ë„ÄÅËôöÁ©∫
                };

                // ÂÖÉÁ¥†Êò†Â∞Ñ
                const allElements = [
                    { name: 'Ê©°ÁöÆ', id: TYPES.EMPTY, uiColor: '#EEEEEE', mdi: 'mdi-eraser', bi: 'bi-eraser-fill', emoji: '‚¨õ' },
                    { name: 'Ê≤ôÂúü', id: TYPES.SAND, uiColor: '#FBC02D', mdi: 'mdi-grain', bi: 'bi-circle-fill', emoji: 'üèúÔ∏è' },
                    { name: 'Ê∞¥Ê∫ê', id: TYPES.WATER, uiColor: '#29B6F6', mdi: 'mdi-water', bi: 'bi-droplet-fill', emoji: 'üíß' },
                    { name: 'Â≤©Áü≥', id: TYPES.STONE, uiColor: '#90A4AE', mdi: 'mdi-wall', bi: 'bi-bricks', emoji: 'ü™®' },
                    { name: 'ÁÅ´ÁÑ∞', id: TYPES.FIRE, uiColor: '#FF3D00', mdi: 'mdi-fire', bi: 'bi-fire', emoji: 'üî•' },
                    { name: 'Èõ∑Áîµ', id: TYPES.THUNDER, uiColor: '#FFEB3B', mdi: 'mdi-flash', bi: 'bi-lightning-fill', emoji: '‚ö°' },
                    { name: 'Â≤©ÊµÜ', id: TYPES.LAVA, uiColor: '#FF5722', mdi: 'mdi-volcano', bi: 'bi-fire', emoji: 'üåã' }, // Êñ∞Â¢û
                    { name: '‰∫ëÊúµ', id: TYPES.CLOUD, uiColor: '#E0F7FA', mdi: 'mdi-cloud', bi: 'bi-cloud-fill', emoji: '‚òÅÔ∏è' }, // Êñ∞Â¢û
                    { name: 'ËôöÁ©∫', id: TYPES.VOID, uiColor: '#311B92', mdi: 'mdi-black-mesa', bi: 'bi-circle', emoji: '‚ö´' }, // Êñ∞Â¢û
                    { name: 'Áü≥Ê≤π', id: TYPES.OIL, uiColor: '#5D4037', mdi: 'mdi-water-opacity', bi: 'bi-droplet-half', emoji: 'üõ¢Ô∏è' },
                    { name: 'Ê∞¥Èì∂', id: TYPES.MERCURY, uiColor: '#CFD8DC', mdi: 'mdi-thermometer', bi: 'bi-thermometer-half', emoji: 'üå°Ô∏è' },
                    { name: 'ÈìÄÁüø', id: TYPES.URANIUM, uiColor: '#76FF03', mdi: 'mdi-radioactive', bi: 'bi-radioactive', emoji: '‚ò¢Ô∏è' },
                    { name: 'Ê§çÁâ©', id: TYPES.PLANT, uiColor: '#43A047', mdi: 'mdi-sprout', bi: 'bi-flower1', emoji: 'üå±' },
                    { name: 'ÁôΩËöÅ', id: TYPES.TERMITE, uiColor: '#D7CCC8', mdi: 'mdi-bug', bi: 'bi-bug-fill', emoji: 'üêú' },
                    { name: 'ÁÅ´ËçØ', id: TYPES.GUNPOWDER, uiColor: '#616161', mdi: 'mdi-hexagon-slice-6', bi: 'bi-hexagon-fill', emoji: '‚ö´' },
                    { name: 'C4',   id: TYPES.C4, uiColor: '#3E2723', mdi: 'mdi-land-mine', bi: 'bi-box', emoji: 'üß®' },
                    { name: 'ÈÖ∏Ê∂≤', id: TYPES.ACID, uiColor: '#B2FF59', mdi: 'mdi-bottle-tonic-skull', bi: 'bi-virus', emoji: 'üß™' },
                    { name: 'Êú®Êùê', id: TYPES.WOOD, uiColor: '#8D6E63', mdi: 'mdi-tree', bi: 'bi-tree-fill', emoji: 'ü™µ' },
                    { name: 'Ëí∏Ê±Ω', id: TYPES.STEAM, uiColor: '#CFD8DC', mdi: 'mdi-weather-fog', bi: 'bi-cloud-fill', emoji: 'üå´Ô∏è' },
                    { name: 'ÂÜ∞Âùó', id: TYPES.ICE, uiColor: '#81D4FA', mdi: 'mdi-snowflake', bi: 'bi-snow', emoji: 'üßä' },
                    { name: 'Ê∂≤Ê∞Æ', id: TYPES.NITROGEN, uiColor: '#00B0FF', mdi: 'mdi-snowflake-alert', bi: 'bi-thermometer-snow', emoji: '‚ùÑÔ∏è' },
                    { name: 'Áî≤ÁÉ∑', id: TYPES.METHANE, uiColor: '#E040FB', mdi: 'mdi-gas-cylinder', bi: 'bi-cloud-haze2-fill', emoji: 'üü£' },
                    { name: 'ËΩØËú°', id: TYPES.WAX, uiColor: '#FFF59D', mdi: 'mdi-candle', bi: 'bi-file-fill', emoji: 'üïØÔ∏è' },
                    { name: 'ÁóÖÊØí', id: TYPES.VIRUS, uiColor: '#D500F9', mdi: 'mdi-virus', bi: 'bi-bug', emoji: 'ü¶†' },
                    { name: 'È£üÁõê', id: TYPES.SALT, uiColor: '#FFFFFF', mdi: 'mdi-shaker', bi: 'bi-dice-5', emoji: 'üßÇ' },
                    { name: 'Ê∞¥Ê≥•', id: TYPES.CONCRETE, uiColor: '#757575', mdi: 'mdi-bucket', bi: 'bi-bucket-fill', emoji: 'üß±' },
                    { name: 'Á≠âÁ¶ªÂ≠ê', id: TYPES.PLASMA, uiColor: '#AA00FF', mdi: 'mdi-blur', bi: 'bi-sun-fill', emoji: '‚öõÔ∏è' },
                ];

                const shortcutIds = ref([TYPES.SAND, TYPES.WATER, TYPES.STONE, TYPES.FIRE, TYPES.LAVA, TYPES.CLOUD, TYPES.VOID, TYPES.EMPTY]);
                const selectedElementId = ref(TYPES.SAND);

                const shortcutElements = computed(() => {
                    return shortcutIds.value.map(id => allElements.find(el => el.id === id)).filter(Boolean);
                });

                const selectFromMore = (el) => {
                    selectedElementId.value = el.id;
                    if (!shortcutIds.value.includes(el.id)) {
                        shortcutIds.value.unshift(el.id);
                        if (shortcutIds.value.length > 8) shortcutIds.value.pop();
                    }
                    showMoreMenu.value = false;
                };

                const colorMap = {
                    [TYPES.EMPTY]: [0, 0, 0],
                    [TYPES.SAND]: [240, 200, 80],
                    [TYPES.WATER]: [33, 150, 243],
                    [TYPES.STONE]: [117, 117, 117],
                    [TYPES.FIRE]: [255, 60, 0],
                    [TYPES.ACID]: [178, 255, 89],
                    [TYPES.WOOD]: [121, 85, 72],
                    [TYPES.OIL]: [50, 30, 10],
                    [TYPES.PLANT]: [76, 175, 80],
                    [TYPES.GUNPOWDER]: [60, 60, 60],
                    [TYPES.STEAM]: [200, 210, 220],
                    [TYPES.ICE]: [180, 230, 250],
                    [TYPES.METHANE]: [150, 100, 200],
                    [TYPES.WAX]: [240, 230, 180],
                    [TYPES.C4]: [100, 80, 60],
                    [TYPES.NITROGEN]: [200, 240, 255],
                    [TYPES.VIRUS]: [200, 0, 200],
                    [TYPES.TERMITE]: [200, 180, 160],
                    [TYPES.FUSE]: [50, 100, 50],
                    [TYPES.THUNDER]: [255, 255, 200],
                    [TYPES.MERCURY]: [190, 190, 200],
                    [TYPES.URANIUM]: [100, 255, 100],
                    [TYPES.SALT]: [250, 250, 250],
                    [TYPES.CONCRETE]: [120, 120, 120],
                    [TYPES.PLASMA]: [170, 0, 255],
                    [TYPES.LAVA]: [255, 87, 34], // Ê©ôÁ∫¢Ëâ≤
                    [TYPES.CLOUD]: [230, 245, 250], // ÊûÅÊµÖËìùÁôΩ
                    [TYPES.VOID]: [20, 0, 40] // Ê∑±Á¥´Èªë
                };

                // --- Áâ©ÁêÜÂºïÊìé ---
                let ctx = null, width = 0, height = 0;
                let grid = null, pixelData = null; 
                let isDrawing = false, lastX = -1, lastY = -1;
                let animationId = null;

                watch(resolutionSetting, () => { initGame(); });

                const initGame = () => {
                    if(animationId) cancelAnimationFrame(animationId);
                    const canvas = canvasRef.value;
                    if(!canvas) return;
                    const rect = canvas.getBoundingClientRect();
                    const scale = 12 - resolutionSetting.value;
                    width = Math.floor(rect.width / scale);
                    height = Math.floor(rect.height / scale);
                    canvas.width = width; canvas.height = height;
                    ctx = canvas.getContext('2d', { alpha: false, willReadFrequently: true });
                    grid = new Int8Array(width * height).fill(TYPES.EMPTY);
                    pixelData = ctx.createImageData(width, height);
                    loop();
                };

                const getIdx = (x, y) => x + y * width;
                const isValid = (x, y) => x >= 0 && x < width && y >= 0 && y < height;

                const update = () => {
                    if (isPaused.value) return;
                    let activeCount = 0;

                    for (let y = height - 1; y >= 0; y--) {
                        const startX = Math.random() > 0.5 ? 0 : width - 1;
                        const step = startX === 0 ? 1 : -1;
                        
                        for (let i = 0; i < width; i++) {
                            const x = startX + i * step;
                            const idx = getIdx(x, y);
                            const type = grid[idx];
                            
                            if (type === TYPES.EMPTY || type === TYPES.STONE) continue;
                            activeCount++;

                            if (type === TYPES.SAND || type === TYPES.GUNPOWDER || type === TYPES.WAX || type === TYPES.C4 || type === TYPES.SALT) updatePowder(x, y, idx, type);
                            else if (type === TYPES.WATER || type === TYPES.ACID || type === TYPES.OIL || type === TYPES.NITROGEN || type === TYPES.MERCURY || type === TYPES.CONCRETE || type === TYPES.LAVA) updateLiquid(x, y, idx, type);
                            else if (type === TYPES.FIRE) updateFire(x, y, idx);
                            else if (type === TYPES.STEAM || type === TYPES.METHANE || type === TYPES.PLASMA || type === TYPES.CLOUD) updateGas(x, y, idx, type);
                            else if (type === TYPES.ICE) updateIce(x, y, idx);
                            else if (type === TYPES.VIRUS) updateVirus(x, y, idx);
                            else if (type === TYPES.TERMITE) updateTermite(x, y, idx);
                            else if (type === TYPES.FUSE) updateFuse(x, y, idx);
                            else if (type === TYPES.THUNDER) updateThunder(x, y, idx);
                            else if (type === TYPES.URANIUM) updateUranium(x, y, idx);
                            else if (type === TYPES.VOID) updateVoid(x, y, idx);
                            else if (type === TYPES.PLANT || type === TYPES.WOOD) updateSolid(x, y, idx);
                        }
                    }
                    particleCount.value = activeCount;
                };

                // --- Áâ©ÁêÜË°å‰∏∫Êõ¥Êñ∞ ---
                
                const updatePowder = (x, y, idx, type) => {
                    if (y >= height - 1) return;
                    const belowIdx = getIdx(x, y + 1);
                    const belowType = grid[belowIdx];

                    // ÁõêÊ∫∂Ëß£
                    if (type === TYPES.SALT && belowType === TYPES.WATER) {
                        grid[idx] = TYPES.WATER; grid[belowIdx] = TYPES.WATER; return; 
                    }

                    if (type === TYPES.GUNPOWDER || type === TYPES.C4) {
                        if (checkAround(x, y, TYPES.FIRE) || checkAround(x, y, TYPES.THUNDER) || checkAround(x, y, TYPES.URANIUM) || checkAround(x,y, TYPES.PLASMA) || checkAround(x,y, TYPES.LAVA)) {
                            explode(x, y, type === TYPES.C4 ? 12 : 3); return;
                        }
                    }
                    if (canPass(belowType)) {
                        grid[idx] = (belowType === TYPES.FIRE || belowType === TYPES.LAVA) ? TYPES.EMPTY : belowType; grid[belowIdx] = type; return;
                    }
                    const dir = Math.random() > 0.5 ? 1 : -1;
                    if (isValid(x + dir, y + 1)) {
                         const sideIdx = getIdx(x+dir, y+1);
                         if (canPass(grid[sideIdx])) { grid[idx] = grid[sideIdx]; grid[sideIdx] = type; }
                    }
                };

                const updateLiquid = (x, y, idx, type) => {
                    if (y >= height - 1) return;
                    const belowIdx = getIdx(x, y + 1);
                    const belowType = grid[belowIdx];

                    // Â≤©ÊµÜÂÜ∑Âç¥‰∏éÁ†¥Âùè
                    if (type === TYPES.LAVA) {
                        if (belowType === TYPES.WATER) { grid[idx] = TYPES.STONE; grid[belowIdx] = TYPES.STEAM; return; }
                        if (checkAround(x,y, TYPES.WATER)) { grid[idx] = TYPES.STONE; return; }
                        if (burnable(belowType)) { grid[belowIdx] = TYPES.FIRE; }
                    }

                    if (type === TYPES.CONCRETE) {
                        if (Math.random() < 0.005) { grid[idx] = TYPES.STONE; return; } 
                    }

                    if (type === TYPES.NITROGEN) {
                        if (belowType === TYPES.WATER) { grid[belowIdx] = TYPES.ICE; grid[idx] = TYPES.EMPTY; return; }
                        if (Math.random() < 0.05) { grid[idx] = TYPES.EMPTY; return; }
                    }

                    if (canPass(belowType)) { grid[idx] = belowType; grid[belowIdx] = type; return; }
                    
                    // ÂØÜÂ∫¶: Ê∞¥Èì∂ > Ê∑∑ÂáùÂúü > Â≤©ÊµÜ > Ê∞¥/ÈÖ∏ > Ê≤π
                    if (type === TYPES.MERCURY && (belowType === TYPES.WATER || belowType === TYPES.ACID || belowType === TYPES.OIL || belowType === TYPES.CONCRETE || belowType === TYPES.LAVA)) {
                        grid[idx] = belowType; grid[belowIdx] = TYPES.MERCURY; return;
                    }
                    else if (type === TYPES.CONCRETE && (belowType === TYPES.WATER || belowType === TYPES.ACID || belowType === TYPES.OIL || belowType === TYPES.LAVA)) {
                         grid[idx] = belowType; grid[belowIdx] = TYPES.CONCRETE; return;
                    }
                    else if (type === TYPES.LAVA && (belowType === TYPES.WATER || belowType === TYPES.ACID || belowType === TYPES.OIL)) {
                         grid[idx] = belowType; grid[belowIdx] = TYPES.LAVA; return;
                    }
                    else if ((type === TYPES.WATER || type === TYPES.ACID) && belowType === TYPES.OIL) {
                         grid[idx] = TYPES.OIL; grid[belowIdx] = type; return;
                    }
                    
                    const dir = Math.random() > 0.5 ? 1 : -1;
                    if (type === TYPES.CONCRETE && Math.random() < 0.7) return; 

                    if (isValid(x+dir, y) && canPass(grid[getIdx(x+dir, y)])) {
                        grid[idx] = grid[getIdx(x+dir, y)]; grid[getIdx(x+dir, y)] = type;
                    }
                };

                const updateGas = (x, y, idx, type) => {
                    if (y <= 0) { grid[idx] = TYPES.EMPTY; return; }
                    if (Math.random() < 0.6) return; 

                    const upIdx = getIdx(x, y - 1);
                    const upType = grid[upIdx];
                    
                    // ‰∫ëÊúµ‰∏ãÈõ®
                    if (type === TYPES.CLOUD) {
                        if (Math.random() < 0.01 && isValid(x, y+1) && grid[getIdx(x, y+1)] === TYPES.EMPTY) {
                            grid[getIdx(x, y+1)] = TYPES.WATER; 
                        }
                    }

                    if (type === TYPES.PLASMA) {
                         if (upType !== TYPES.EMPTY && upType !== TYPES.PLASMA && upType !== TYPES.VOID) {
                             if(Math.random()<0.5) grid[upIdx] = TYPES.FIRE; 
                             else grid[upIdx] = TYPES.EMPTY;
                         }
                    }

                    if (type === TYPES.METHANE && (checkAround(x,y, TYPES.FIRE) || checkAround(x,y, TYPES.THUNDER) || checkAround(x,y, TYPES.PLASMA) || checkAround(x,y, TYPES.LAVA))) { explode(x,y, 4); return; }

                    if (upType === TYPES.EMPTY || upType === TYPES.WATER || upType === TYPES.OIL) {
                        grid[idx] = upType; grid[upIdx] = type; return;
                    }
                    if (Math.random() < 0.5) {
                        const dir = Math.random() > 0.5 ? 1 : -1;
                        if (isValid(x+dir, y-1) && grid[getIdx(x+dir, y-1)] === TYPES.EMPTY) {
                             grid[idx] = TYPES.EMPTY; grid[getIdx(x+dir, y-1)] = type;
                        }
                    }
                };

                const updateVoid = (x, y, idx) => {
                    // ËôöÁ©∫ÂêûÂô¨Âë®Âõ¥‰∏ÄÂàá
                    const check = [[0,1],[0,-1],[1,0],[-1,0]];
                    for(let o of check) {
                        const nx = x+o[0], ny = y+o[1];
                        if(isValid(nx,ny) && grid[getIdx(nx,ny)] !== TYPES.EMPTY && grid[getIdx(nx,ny)] !== TYPES.VOID) {
                            grid[getIdx(nx,ny)] = TYPES.EMPTY;
                        }
                    }
                };

                const updateFire = (x, y, idx) => {
                    if (Math.random() < 0.2) { grid[idx] = TYPES.EMPTY; return; } 
                    if (y > 0) {
                        const upIdx = getIdx(x, y - 1);
                        const upType = grid[upIdx];
                        if (upType === TYPES.EMPTY) {
                            if (Math.random() < 0.3) grid[upIdx] = Math.random() < 0.3 ? TYPES.STEAM : TYPES.FIRE;
                        }
                        else if (burnable(upType)) grid[upIdx] = TYPES.FIRE;
                        else if (upType === TYPES.WATER || upType === TYPES.ICE) { grid[idx] = TYPES.EMPTY; grid[upIdx] = TYPES.STEAM; }
                    }
                    if(Math.random()<0.1) {
                        const dir = Math.random()>0.5?1:-1;
                        if(isValid(x+dir, y) && burnable(grid[getIdx(x+dir, y)])) grid[getIdx(x+dir, y)] = TYPES.FIRE;
                    }
                };

                const updateUranium = (x, y, idx) => {
                    if(Math.random() < 0.05) {
                        const offsets = [[0,1],[0,-1],[1,0],[-1,0]];
                        const o = offsets[Math.floor(Math.random()*4)];
                        const nx=x+o[0], ny=y+o[1];
                        if(isValid(nx,ny)) {
                            const t = grid[getIdx(nx,ny)];
                            if(t === TYPES.WATER) grid[getIdx(nx,ny)] = TYPES.STEAM;
                            else if(burnable(t)) grid[getIdx(nx,ny)] = TYPES.FIRE;
                            else if(t === TYPES.EMPTY && Math.random()<0.05) grid[getIdx(nx,ny)] = TYPES.FIRE; 
                        }
                    }
                };

                const updateTermite = (x, y, idx) => {
                    const dir = Math.random()>0.5?1:-1;
                    if(isValid(x+dir, y) && grid[getIdx(x+dir,y)] === TYPES.EMPTY) {
                        grid[idx] = TYPES.EMPTY; grid[getIdx(x+dir,y)] = TYPES.TERMITE;
                    } else if (isValid(x+dir, y+1) && grid[getIdx(x+dir,y+1)] === TYPES.EMPTY) {
                        grid[idx] = TYPES.EMPTY; grid[getIdx(x+dir,y+1)] = TYPES.TERMITE;
                    }
                    const check = [[0,1],[0,-1],[1,0],[-1,0]];
                    for(let o of check) {
                        const nx = x+o[0], ny = y+o[1];
                        if(isValid(nx,ny) && (grid[getIdx(nx,ny)] === TYPES.WOOD || grid[getIdx(nx,ny)] === TYPES.PLANT)) {
                            grid[getIdx(nx,ny)] = TYPES.EMPTY; 
                            if(Math.random()<0.05) grid[idx] = TYPES.EMPTY; 
                        }
                    }
                };

                const updateFuse = (x, y, idx) => {
                    if (Math.random() < 0.05 && (checkAround(x,y, TYPES.FIRE) || checkAround(x,y, TYPES.THUNDER) || checkAround(x,y, TYPES.LAVA))) {
                        grid[idx] = TYPES.FIRE;
                    }
                };

                const updateThunder = (x, y, idx) => {
                    grid[idx] = TYPES.EMPTY; 
                    let ty = y + 1;
                    while(ty < height) {
                        const tidx = getIdx(x, ty);
                        const t = grid[tidx];
                        if (t !== TYPES.EMPTY && t !== TYPES.FIRE) {
                            if(burnable(t)) grid[tidx] = TYPES.FIRE;
                            else if(t === TYPES.STONE) grid[tidx] = TYPES.SAND; 
                            else if(t === TYPES.SAND) grid[tidx] = TYPES.STEAM; 
                            explode(x, ty, 2);
                            return;
                        }
                        grid[tidx] = TYPES.FIRE; 
                        ty++;
                    }
                };

                const updateVirus = (x, y, idx) => {
                    const check = [[0,1],[0,-1],[1,0],[-1,0]];
                    let hasFood = false;
                    for(let o of check) {
                        const nx = x+o[0], ny = y+o[1];
                        if(isValid(nx, ny)) {
                            const t = grid[getIdx(nx, ny)];
                            if (t === TYPES.PLANT || t === TYPES.WOOD || t === TYPES.WAX) {
                                grid[getIdx(nx, ny)] = TYPES.VIRUS; hasFood = true;
                            }
                        }
                    }
                    if(!hasFood && Math.random() < 0.05) grid[idx] = TYPES.EMPTY;
                };
                
                const updateIce = (x, y, idx) => {
                    if (checkAround(x, y, TYPES.FIRE) || checkAround(x, y, TYPES.LAVA)) grid[idx] = TYPES.WATER;
                    else if (Math.random() < 0.001) grid[idx] = TYPES.WATER; 
                };
                
                const updateSolid = (x, y, idx) => {
                    if (grid[idx] === TYPES.PLANT && Math.random() < 0.005) {
                        if (y > 0 && grid[getIdx(x, y-1)] === TYPES.EMPTY) grid[getIdx(x, y-1)] = TYPES.PLANT;
                    }
                };

                const canPass = (t) => t === TYPES.EMPTY || t === TYPES.FIRE || t === TYPES.STEAM || t === TYPES.METHANE || t === TYPES.PLASMA || t === TYPES.CLOUD;
                const burnable = (t) => [TYPES.WOOD, TYPES.PLANT, TYPES.OIL, TYPES.GUNPOWDER, TYPES.METHANE, TYPES.WAX, TYPES.C4, TYPES.VIRUS, TYPES.TERMITE, TYPES.FUSE].includes(t);
                
                const checkAround = (x, y, target) => {
                    const offsets = [[0,1], [0,-1], [1,0], [-1,0]];
                    for(let o of offsets) if(isValid(x+o[0], y+o[1]) && grid[getIdx(x+o[0], y+o[1])] === target) return true;
                    return false;
                };

                const explode = (cx, cy, radius) => {
                    grid[getIdx(cx, cy)] = TYPES.FIRE;
                    for(let dy=-radius; dy<=radius; dy++){
                        for(let dx=-radius; dx<=radius; dx++){
                            if(dx*dx+dy*dy <= radius*radius){
                                const nx = cx+dx, ny = cy+dy;
                                if(isValid(nx, ny)){
                                    if(Math.random() < 0.8) grid[getIdx(nx, ny)] = TYPES.FIRE;
                                    else grid[getIdx(nx, ny)] = TYPES.EMPTY;
                                }
                            }
                        }
                    }
                };

                // --- Ê∏≤Êüì ---
                const draw = () => {
                    const data = pixelData.data;
                    for (let i = 0; i < grid.length; i++) {
                        const type = grid[i];
                        const col = colorMap[type];
                        const offset = i * 4;
                        let noise = (type !== TYPES.EMPTY) ? (Math.random() - 0.5) * 15 : 0;
                        if(type===TYPES.FIRE || type===TYPES.URANIUM || type===TYPES.PLASMA || type===TYPES.LAVA) noise*=3;
                        data[offset] = Math.min(255, Math.max(0, col[0] + noise));
                        data[offset + 1] = Math.min(255, Math.max(0, col[1] + noise));
                        data[offset + 2] = Math.min(255, Math.max(0, col[2] + noise));
                        data[offset + 3] = 255;
                    }
                    ctx.putImageData(pixelData, 0, 0);
                };

                let lastTime=0, frameCount=0, lastFpsTime=0;
                const loop = (t) => {
                    if(!lastTime) lastTime=t;
                    update(); draw();
                    frameCount++;
                    if(t - lastFpsTime >= 1000) { fps.value = frameCount; frameCount=0; lastFpsTime=t; }
                    animationId = requestAnimationFrame(loop);
                };

                const getCanvasCoords = (e) => {
                    const rect = canvasRef.value.getBoundingClientRect();
                    const scale = 12 - resolutionSetting.value;
                    const cx = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
                    const cy = (e.touches && e.touches.length > 0) ? e.touches[0].clientY : e.clientY;
                    return { x: Math.floor((cx - rect.left)/scale), y: Math.floor((cy - rect.top)/scale) };
                };

                const placeElement = (cx, cy) => {
                    const size = Math.floor(brushSize.value);
                    const shape = brushShape.value;
                    const elementId = selectedElementId.value;
                    const r = Math.floor(size / 2);
                    for (let dy = -r; dy <= r; dy++) {
                        for (let dx = -r; dx <= r; dx++) {
                            const nx = cx + dx, ny = cy + dy;
                            if (isValid(nx, ny)) {
                                if (shape === 'square' || (dx*dx + dy*dy <= r*r)) {
                                    const cur = grid[getIdx(nx, ny)];
                                    if (elementId === TYPES.EMPTY || cur === TYPES.EMPTY || [TYPES.WATER, TYPES.OIL, TYPES.STEAM, TYPES.METHANE, TYPES.FIRE, TYPES.ACID, TYPES.VIRUS, TYPES.TERMITE, TYPES.MERCURY, TYPES.PLASMA, TYPES.LAVA, TYPES.CLOUD].includes(cur)) {
                                        grid[getIdx(nx, ny)] = elementId;
                                    }
                                }
                            }
                        }
                    }
                };

                const drawLine = (x0, y0, x1, y1) => {
                    const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
                    const sx = (x0 < x1) ? 1 : -1, sy = (y0 < y1) ? 1 : -1;
                    let err = dx - dy;
                    while(true) {
                        placeElement(x0, y0);
                        if (x0 === x1 && y0 === y1) break;
                        const e2 = 2 * err;
                        if (e2 > -dy) { err -= dy; x0 += sx; }
                        if (e2 < dx) { err += dx; y0 += sy; }
                    }
                };

                const handleStart = (e) => { isDrawing=true; const {x,y}=getCanvasCoords(e); lastX=x; lastY=y; placeElement(x,y); };
                const handleMove = (e) => { if(!isDrawing)return; const {x,y}=getCanvasCoords(e); drawLine(lastX,lastY,x,y); lastX=x; lastY=y; };
                const handleEnd = () => { isDrawing=false; lastX=-1; lastY=-1; };

                onMounted(async () => {
                    await nextTick();
                    setTimeout(() => {}, 800);
                    setTimeout(() => { initGame(); }, 1600);
                    setTimeout(() => {
                        const loader = document.getElementById('loading-screen');
                        if(loader) {
                            loader.style.opacity = '0';
                            setTimeout(() => loader.remove(), 600);
                        }
                    }, 2400);

                    const c = canvasRef.value;
                    c.addEventListener('mousedown', handleStart); window.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleEnd);
                    c.addEventListener('touchstart', (e)=>{e.preventDefault(); handleStart(e)}, {passive:false});
                    c.addEventListener('touchmove', (e)=>{e.preventDefault(); handleMove(e)}, {passive:false});
                    c.addEventListener('touchend', handleEnd);
                    
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => initGame(), 300);
                    });
                });

                const toggleMenu = () => isMenuOpen.value = !isMenuOpen.value;

                return {
                    canvasRef, fps, particleCount, isPaused, brushSize, brushShape, 
                    selectedElementId, allElements, shortcutElements, 
                    isMenuOpen, toggleMenu, showMoreMenu, selectFromMore,
                    settingsDialog, resolutionSetting, 
                    iconSourceType, iconSources, changeIconSource,
                    hudMode, // Êñ∞Â¢ûÔºöHUDÊ®°Âºè
                    width, height, // Áî®‰∫éHUDÊòæÁ§∫
                    togglePause: () => isPaused.value = !isPaused.value,
                    clearCanvas: () => grid && grid.fill(TYPES.EMPTY)
                };
            }
        });

        app.use(vuetify);
        app.mount('#app');
    </script>
</body>
</html>

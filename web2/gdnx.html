<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Orbit Reverse: Quantum Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Roboto+Mono&display=swap');

        :root {
            --md-bg: #141218;
            --md-surface: #1C1B1F;
            --md-surface-container: #2B2930;
            --md-primary: #D0BCFF;
            --md-on-primary: #381E72;
            --md-secondary: #CCC2DC;
            --md-tertiary: #EFB8C8;
            --md-error: #F2B8B5;
            --md-on-bg: #E6E1E5;
            --md-outline: #938F99;
            --font-family: 'Roboto', sans-serif;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        body {
            margin: 0;
            background-color: var(--md-bg);
            color: var(--md-on-bg);
            font-family: var(--font-family);
            overflow: hidden;
            height: 100vh;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        #ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* å·¦ä¸Šè§’æºä»£ç æŒ‰é’® */
        .source-btn {
            position: absolute;
            top: 16px;
            left: 16px;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            color: var(--md-secondary);
            font-family: 'Roboto Mono', monospace;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.05);
            z-index: 50;
        }
        .source-btn:active { background: rgba(255,255,255,0.2); }

        /* æºä»£ç å¼¹çª— */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
            opacity: 0; pointer-events: none; transition: 0.3s;
        }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        
        .code-window {
            width: 90%; max-width: 600px; height: 70%;
            background: var(--md-surface);
            border-radius: 16px;
            border: 1px solid var(--md-outline);
            display: flex; flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .code-header {
            padding: 12px 16px; background: var(--md-surface-container);
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .code-content {
            flex: 1; padding: 16px;
            background: #000;
            color: #0f0;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
            border: none;
            resize: none;
            outline: none;
            user-select: text !important; /* å…è®¸å¤åˆ¶ */
            -webkit-user-select: text !important;
        }

        /* é¡¶éƒ¨ HUD */
        .hud {
            position: absolute;
            top: 0;
            width: 100%;
            padding: 16px 24px;
            padding-left: 70px;
            display: flex;
            justify-content: flex-end;
            gap: 20px;
            align-items: center;
            font-weight: 700;
            background: linear-gradient(180deg, rgba(20,18,24,0.9) 0%, rgba(20,18,24,0) 100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.0, 0, 1.0);
            transform: translateY(-100%);
        }
        .hud.visible { transform: translateY(0); }

        .hud-item { display: flex; flex-direction: column; align-items: center; }
        .hud-label { font-size: 0.7rem; color: var(--md-secondary); text-transform: uppercase; letter-spacing: 1px; }
        .hud-value { font-size: 1.2rem; color: var(--md-primary); }

        /* é“å…·æ  HUD */
        .item-hud {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            pointer-events: none;
            opacity: 0;
            transition: 0.3s;
        }
        .item-hud.visible { opacity: 1; pointer-events: auto; }

        .item-btn {
            width: 60px; height: 60px;
            border-radius: 50%;
            background: rgba(43, 41, 48, 0.8);
            border: 2px solid var(--md-outline);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
            font-size: 0.7rem;
            position: relative;
            cursor: pointer;
            backdrop-filter: blur(4px);
        }
        .item-btn:active { transform: scale(0.9); }
        .item-btn.active { border-color: var(--md-primary); box-shadow: 0 0 15px var(--md-primary); }
        .item-count {
            position: absolute; top: -5px; right: -5px;
            background: var(--md-error); color: black;
            font-weight: bold; border-radius: 10px;
            padding: 2px 6px; font-size: 0.7rem;
        }
        .item-icon { font-size: 1.2rem; margin-bottom: 2px; }

        /* å¡ç‰‡ç³»ç»Ÿ */
        .card {
            pointer-events: auto;
            background-color: var(--md-surface-container);
            border-radius: 28px;
            padding: 32px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: 85%;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border: 1px solid rgba(255,255,255,0.05);
            position: absolute;
            opacity: 1; transform: scale(1) translateY(0);
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 20;
        }

        .card.hidden { opacity: 0; pointer-events: none; transform: scale(0.9) translateY(20px); z-index: 0; }

        h1 { margin: 0; font-size: 1.8rem; background: linear-gradient(45deg, var(--md-primary), var(--md-tertiary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .btn {
            background-color: var(--md-primary); color: var(--md-on-primary); border: none; padding: 12px 24px;
            border-radius: 100px; font-size: 1rem; font-weight: 500; cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px; text-transform: uppercase;
        }
        .btn-secondary { background-color: transparent; border: 1px solid var(--md-outline); color: var(--md-primary); }

        /* å•†åº—ç½‘æ ¼ */
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; max-height: 300px; overflow-y: auto; padding: 4px; -webkit-overflow-scrolling: touch; }
        .shop-item {
            background: rgba(0,0,0,0.2); border-radius: 16px; padding: 12px;
            display: flex; flex-direction: column; align-items: center; gap: 8px;
            cursor: pointer; border: 2px solid transparent; position: relative;
        }
        .shop-item.selected { border-color: var(--md-primary); background: rgba(208, 188, 255, 0.1); }
        .item-badge { position: absolute; top: 4px; right: 4px; background: var(--md-tertiary); color: black; font-size: 0.6rem; padding: 2px 4px; border-radius: 4px; font-weight: bold; }

        .floating-text {
            position: absolute; color: var(--md-tertiary); font-weight: bold; font-size: 1.2rem;
            pointer-events: none; animation: floatUp 0.8s ease-out forwards; z-index: 5;
        }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-50px); opacity: 0; } }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- æºä»£ç æŒ‰é’® -->
    <div class="source-btn" onclick="ui.toggleSource(true)">&lt; / &gt;</div>

    <!-- æºä»£ç çª—å£ -->
    <div id="sourceModal" class="modal-overlay">
        <div class="code-window">
            <div class="code-header">
                <span style="color:white; font-weight:bold;">Source Code</span>
                <span style="color:var(--md-error); cursor:pointer; padding: 0 10px;" onclick="ui.toggleSource(false)">âœ•</span>
            </div>
            <!-- è¿™é‡Œå·²ä¿®æ”¹ï¼ŒåŠ ä¸Šäº†idï¼Œå»æ‰äº†å†…å®¹ï¼Œç”±JSè‡ªåŠ¨å¡«å…… -->
            <textarea id="sourceCodeArea" class="code-content" readonly></textarea>
        </div>
    </div>

    <!-- HUD -->
    <div id="gameHud" class="hud">
        <div class="hud-item">
            <span class="hud-label">Time</span>
            <span class="hud-value" id="hudTime">00:00</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Score</span>
            <span class="hud-value" id="hudScore">0</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Stardust</span>
            <span class="hud-value" id="hudMoney" style="color: var(--md-tertiary)">0</span>
        </div>
    </div>

    <!-- é“å…·æŒ‰é’®æ  -->
    <div id="itemHud" class="item-hud">
        <div class="item-btn" id="btnSlow" onmousedown="game.useItem('slow', event)" ontouchstart="game.useItem('slow', event)">
            <div class="item-count" id="countSlow">0</div>
            <span class="item-icon">â„ï¸</span>
            <span>æ…¢é€Ÿ</span>
        </div>
        <div class="item-btn" id="btnInvincible" onmousedown="game.useItem('invincible', event)" ontouchstart="game.useItem('invincible', event)">
            <div class="item-count" id="countInvincible">0</div>
            <span class="item-icon">ğŸ›¡ï¸</span>
            <span>æ— æ•Œ</span>
        </div>
    </div>

    <div id="ui-layer">
        
        <!-- ä¸»èœå• -->
        <div id="menuCard" class="card">
            <h1>è½¨é“é€†è¡Œ</h1>
            <p>ç‚¹å‡»å±å¹•åè½¬å¼•åŠ›è½¨é“ã€‚<br>åˆ©ç”¨é“å…·å’Œç‰©ç†èº²é¿è™šç©ºç¢ç‰‡ã€‚</p>
            <div style="display: flex; justify-content: space-between; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 16px;">
                <span style="color: var(--md-secondary)">æŒæœ‰æ˜Ÿå°˜</span>
                <span id="menuMoney" style="color: var(--md-tertiary); font-weight: bold;">0</span>
            </div>
            <button class="btn" onclick="game.start()">å¼€å§‹ä»»åŠ¡</button>
            <button class="btn btn-secondary" onclick="ui.showShop()">é‡å­å•†åº—</button>
        </div>

        <!-- å•†åº— -->
        <div id="shopCard" class="card hidden">
            <h2>è¡¥ç»™ç«™</h2>
            <div class="shop-grid" id="shopGrid"></div>
            <button class="btn btn-secondary" onclick="ui.showMenu()">è¿”å›</button>
        </div>

        <!-- ç»“ç®— -->
        <div id="gameOverCard" class="card hidden">
            <h1 style="color: var(--md-error)">ä»»åŠ¡å¤±è´¥</h1>
            <div>
                <p>æœ€ç»ˆå¾—åˆ†</p>
                <div id="finalScore" style="font-size: 2.5rem; font-weight: bold; color: var(--md-primary);">0</div>
            </div>
            <div>
                <p>å­˜æ´»æ—¶é—´: <span id="finalTime" style="color: white">00:00</span></p>
                <p>è·å¾—æ˜Ÿå°˜: <span id="earnedMoney" style="color: var(--md-tertiary)">+0</span></p>
            </div>
            <button class="btn" onclick="game.start()">å†æ¬¡å°è¯•</button>
            <button class="btn btn-secondary" onclick="ui.showMenu()">è¿”å›ä¸»é¡µ</button>
        </div>
    </div>

    <script>
        // --- æ•°æ® ---
        const GameData = {
            money: 0,
            ownedSkins: ['default'],
            equippedSkin: 'default',
            inventory: { slow: 0, invincible: 0 },
            
            items: [
                // çš®è‚¤
                { id: 'default', type: 'skin', name: 'åŸå‹æœº', color: '#D0BCFF', price: 0 },
                { id: 'lime', type: 'skin', name: 'æ¯’æ¶²ç»¿', color: '#B8F397', price: 200 },
                { id: 'gold', type: 'skin', name: 'å¤ªé˜³è€€æ–‘', color: '#FFD700', price: 500 },
                { id: 'void', type: 'skin', name: 'è™šç©ºé»‘æ´', color: '#E0E0E0', price: 3000 },
                // æ¶ˆè€—å“
                { id: 'slow', type: 'consumable', name: 'æ—¶ç©ºç¼“é€Ÿ', icon: 'â„ï¸', price: 50, desc: 'æ…¢é€Ÿ20ç§’' },
                { id: 'invincible', type: 'consumable', name: 'ç»å¯¹é˜²å¾¡', icon: 'ğŸ›¡ï¸', price: 100, desc: 'æ— æ•Œ10ç§’' }
            ],

            load: function() {
                try {
                    const saved = localStorage.getItem('orbit_save_v3');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.money = data.money || 0;
                        this.ownedSkins = data.ownedSkins || ['default'];
                        this.equippedSkin = data.equippedSkin || 'default';
                        this.inventory = { ...this.inventory, ...data.inventory };
                    }
                } catch(e) {}
            },
            save: function() {
                localStorage.setItem('orbit_save_v3', JSON.stringify({
                    money: this.money,
                    ownedSkins: this.ownedSkins,
                    equippedSkin: this.equippedSkin,
                    inventory: this.inventory
                }));
            },
            getColor: function() {
                const s = this.items.find(s => s.id === this.equippedSkin);
                return s ? s.color : '#D0BCFF';
            }
        };

        // --- éŸ³é¢‘ ---
        const AudioSys = {
            ctx: null,
            init: function() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            },
            playTap: () => AudioSys.playTone(600, 'sine', 0.15),
            playScore: () => AudioSys.playTone(1200, 'triangle', 0.1, 0.05),
            playBuy: () => AudioSys.playTone(880, 'square', 0.3, 0.05),
            playPowerup: () => AudioSys.playTone(400, 'sine', 0.5, 0.2), 
            playDie: () => AudioSys.playTone(150, 'sawtooth', 0.6, 0.2)
        };

        // --- æ¸¸æˆ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, centerX, centerY;
        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr; canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = width + 'px'; canvas.style.height = height + 'px';
            centerX = width / 2; centerY = height / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                const a = Math.random() * 6.28; const s = Math.random() * 4;
                this.vx = Math.cos(a)*s; this.vy = Math.sin(a)*s; this.life=1.0;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.03; }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, 6.28); ctx.fill(); ctx.globalAlpha = 1;
            }
        }

        class Enemy {
            constructor(diff) {
                this.dist = Math.max(width, height)/2 + 50;
                this.angle = Math.random() * 6.28;
                this.speed = (2.5 + Math.random()*2) * (1 + diff * 0.1);
                this.radius = 10 + Math.random()*6;
                this.hue = (Date.now()/20)%360;
                this.type = 'normal';
                if(diff>2 && Math.random()>0.7) this.type='wobble';
                if(diff>4 && Math.random()>0.85) this.type='dash';
                this.wobbleOff = Math.random()*10;
            }
            update(slowFactor) {
                let mod = 1;
                if(this.type==='wobble') { this.angle += Math.sin(Date.now()/300 + this.wobbleOff)*0.015; mod=1.1; }
                if(this.type==='dash') { mod = this.dist<200 ? 3.0 : 0.6; }
                this.dist -= this.speed * mod * slowFactor;
            }
            draw() {
                const x = centerX + Math.cos(this.angle)*this.dist;
                const y = centerY + Math.sin(this.angle)*this.dist;
                ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
                ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 10;
                ctx.beginPath();
                this.type==='wobble' ? ctx.rect(x-this.radius,y-this.radius,this.radius*2,this.radius*2) : ctx.arc(x,y,this.radius,0,6.28);
                ctx.fill(); ctx.shadowBlur = 0;
            }
        }

        const game = {
            state: 'menu',
            score: 0, moneySess: 0, startTime: 0,
            angle: 0, dir: 1, enemies: [], particles: [], animId: null,
            slowTimer: 0, invincibleTimer: 0,

            init: function() {
                GameData.load();
                ui.updateLabels();
                this.renderStatic();
            },

            start: function() {
                this.state = 'playing';
                this.score = 0; this.moneySess = 0;
                this.enemies = []; this.particles = [];
                this.slowTimer = 0; this.invincibleTimer = 0;
                this.startTime = Date.now();
                
                ui.showHud(true);
                ui.hideCards();
                ui.updateItemCounts();
                
                if(this.animId) cancelAnimationFrame(this.animId);
                this.loop();
            },

            useItem: function(type, e) {
                if (e) e.stopPropagation();
                if (this.state !== 'playing') return;
                
                if (GameData.inventory[type] > 0) {
                    GameData.inventory[type]--;
                    GameData.save();
                    ui.updateItemCounts();
                    AudioSys.playPowerup();

                    if (type === 'slow') {
                        this.slowTimer = 1200; 
                        ui.floatText("Time Slow!", centerX, centerY - 50);
                    } else if (type === 'invincible') {
                        this.invincibleTimer = 600; 
                        ui.floatText("Invincible!", centerX, centerY - 50);
                    }
                }
            },

            input: function() {
                if (this.state !== 'playing') return;
                this.dir *= -1;
                AudioSys.playTap();
            },

            loop: function() {
                if (this.state !== 'playing') return;

                if (this.slowTimer > 0) this.slowTimer--;
                if (this.invincibleTimer > 0) this.invincibleTimer--;

                const slowFactor = this.slowTimer > 0 ? 0.5 : 1.0;
                const isInvincible = this.invincibleTimer > 0;

                this.angle += 0.05 * this.dir * slowFactor;
                
                const sec = Math.floor((Date.now() - this.startTime)/1000);
                document.getElementById('hudTime').innerText = 
                    `${Math.floor(sec/60).toString().padStart(2,'0')}:${(sec%60).toString().padStart(2,'0')}`;

                const diff = 1 + Math.floor(sec/10) + Math.floor(this.score/50);
                if (Math.random() < (0.02 + (diff*0.005)) * slowFactor) {
                    this.enemies.push(new Enemy(diff));
                }

                ctx.fillStyle = this.slowTimer > 0 ? 'rgba(20, 30, 50, 0.2)' : 'rgba(20, 18, 24, 0.2)';
                ctx.fillRect(0, 0, width, height);
                
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(centerX, centerY, 65, 0, 6.28); ctx.stroke();

                const pColor = GameData.getColor();
                const pos = [
                    {x: centerX + Math.cos(this.angle)*65, y: centerY + Math.sin(this.angle)*65},
                    {x: centerX + Math.cos(this.angle+Math.PI)*65, y: centerY + Math.sin(this.angle+Math.PI)*65}
                ];

                if (Date.now()%4===0) pos.forEach(p => this.particles.push(new Particle(p.x, p.y, pColor)));
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i]; p.update(); p.draw(); if(p.life<=0)this.particles.splice(i,1);
                }

                if (isInvincible) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(centerX, centerY, 80 + Math.sin(Date.now()/100)*5, 0, 6.28); ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.1)'; ctx.fill();
                    document.getElementById('btnInvincible').classList.add('active');
                } else {
                    document.getElementById('btnInvincible').classList.remove('active');
                }
                if (this.slowTimer > 0) document.getElementById('btnSlow').classList.add('active');
                else document.getElementById('btnSlow').classList.remove('active');

                ctx.fillStyle = pColor; ctx.shadowColor = pColor; ctx.shadowBlur = 15;
                pos.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, 6.28); ctx.fill(); });
                ctx.shadowBlur = 0;
                ctx.strokeStyle = pColor; ctx.beginPath(); ctx.moveTo(pos[0].x, pos[0].y); ctx.lineTo(pos[1].x, pos[1].y); ctx.stroke();

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    let e = this.enemies[i];
                    e.update(slowFactor);
                    e.draw();

                    const hit = e.radius + 8;
                    const d1 = Math.hypot(pos[0].x - (centerX+Math.cos(e.angle)*e.dist), pos[0].y - (centerY+Math.sin(e.angle)*e.dist));
                    const d2 = Math.hypot(pos[1].x - (centerX+Math.cos(e.angle)*e.dist), pos[1].y - (centerY+Math.sin(e.angle)*e.dist));
                    
                    if (d1 < hit || d2 < hit) {
                        if (isInvincible) {
                            this.score += 5; 
                            ui.floatText("Shield!", e.dist*Math.cos(e.angle)+centerX, e.dist*Math.sin(e.angle)+centerY);
                            this.enemies.splice(i, 1);
                            continue;
                        } else {
                            this.gameOver();
                            return;
                        }
                    }
                    if (e.dist < 10) {
                        this.score += 10; this.moneySess += 1; GameData.money += 1;
                        ui.floatText("+10", centerX, centerY - 20);
                        document.getElementById('hudScore').innerText = this.score;
                        document.getElementById('hudMoney').innerText = GameData.money;
                        AudioSys.playScore();
                        this.enemies.splice(i, 1);
                    }
                }
                this.animId = requestAnimationFrame(() => this.loop());
            },

            gameOver: function() {
                this.state = 'gameover';
                AudioSys.playDie();
                GameData.save();
                ui.showHud(false);
                
                const pColor = GameData.getColor();
                for(let i=0; i<30; i++) this.particles.push(new Particle(centerX, centerY, pColor));
                
                setTimeout(() => {
                    document.getElementById('finalScore').innerText = this.score;
                    document.getElementById('finalTime').innerText = document.getElementById('hudTime').innerText;
                    document.getElementById('earnedMoney').innerText = "+" + this.moneySess;
                    ui.switchCard('gameOverCard');
                }, 500);
            },

            renderStatic: function() {
                ctx.fillStyle = '#141218'; ctx.fillRect(0,0,width,height);
                ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.beginPath(); ctx.arc(centerX, centerY, 65, 0, 6.28); ctx.stroke();
            }
        };

        // --- UI ---
        const ui = {
            hideCards: () => document.querySelectorAll('.card').forEach(c => c.classList.add('hidden')),
            switchCard: (id) => { ui.hideCards(); document.getElementById(id)?.classList.remove('hidden'); },
            showHud: (show) => {
                const hud = document.getElementById('gameHud');
                const itemHud = document.getElementById('itemHud');
                if(show) { hud.classList.add('visible'); itemHud.classList.add('visible'); }
                else { hud.classList.remove('visible'); itemHud.classList.remove('visible'); }
            },
            showMenu: () => {
                game.state = 'menu';
                if(game.animId) cancelAnimationFrame(game.animId);
                game.renderStatic();
                ui.updateLabels();
                ui.switchCard('menuCard');
            },
            showShop: () => { ui.buildShop(); ui.switchCard('shopCard'); },
            updateLabels: () => {
                document.getElementById('menuMoney').innerText = GameData.money;
                document.getElementById('hudMoney').innerText = GameData.money;
            },
            updateItemCounts: () => {
                document.getElementById('countSlow').innerText = GameData.inventory.slow;
                document.getElementById('countInvincible').innerText = GameData.inventory.invincible;
                document.getElementById('btnSlow').style.opacity = GameData.inventory.slow > 0 ? '1' : '0.5';
                document.getElementById('btnInvincible').style.opacity = GameData.inventory.invincible > 0 ? '1' : '0.5';
            },
            buildShop: () => {
                const grid = document.getElementById('shopGrid'); grid.innerHTML = '';
                GameData.items.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'shop-item';
                    
                    let isEquipped = GameData.equippedSkin === item.id;
                    let isOwned = item.type === 'skin' && GameData.ownedSkins.includes(item.id);
                    if(isEquipped) el.classList.add('selected');

                    let priceText = item.price;
                    let priceColor = 'var(--md-secondary)';
                    
                    if(item.type === 'skin') {
                        if(isEquipped) priceText = "å·²è£…å¤‡";
                        else if(isOwned) { priceText = "è£…å¤‡"; priceColor = "var(--md-primary)"; }
                        else if(GameData.money < item.price) priceColor = "var(--md-error)";
                    } else {
                        el.innerHTML += `<div class="item-badge">æ‹¥: ${GameData.inventory[item.id]||0}</div>`;
                        if(GameData.money < item.price) priceColor = "var(--md-error)";
                    }

                    let iconHtml = '';
                    if(item.type === 'skin') {
                        iconHtml = `<div style="width:30px;height:30px;border-radius:50%;background:${item.color};box-shadow:0 0 10px ${item.color}"></div>`;
                    } else {
                        iconHtml = `<div style="font-size:1.5rem">${item.icon}</div>`;
                    }

                    el.innerHTML = `
                        ${item.type === 'consumable' ? `<div class="item-badge">æ‹¥: ${GameData.inventory[item.id]||0}</div>` : ''}
                        ${iconHtml}
                        <div style="font-weight:bold;font-size:0.9rem">${item.name}</div>
                        <div style="font-size:0.7rem; color:var(--md-secondary)">${item.desc || 'çš®è‚¤'}</div>
                        <div style="color:${priceColor}; font-weight:500; margin-top:4px">${priceText}</div>
                    `;

                    el.onclick = (e) => {
                        e.stopPropagation();
                        if (item.type === 'skin') {
                            if(isOwned) { GameData.equippedSkin = item.id; AudioSys.playTap(); }
                            else if(GameData.money >= item.price) {
                                GameData.money -= item.price; GameData.ownedSkins.push(item.id); GameData.equippedSkin = item.id; AudioSys.playBuy();
                            }
                        } else {
                            if(GameData.money >= item.price) {
                                GameData.money -= item.price;
                                GameData.inventory[item.id] = (GameData.inventory[item.id] || 0) + 1;
                                AudioSys.playBuy();
                            }
                        }
                        GameData.save(); ui.buildShop(); ui.updateLabels();
                    };
                    grid.appendChild(el);
                });
            },
            toggleSource: (show) => {
                const el = document.getElementById('sourceModal');
                if(show) {
                    // è‡ªåŠ¨æ³¨å…¥å½“å‰é¡µé¢ä»£ç ï¼Œè§£å†³é—­åˆæ ‡ç­¾é—®é¢˜
                    document.getElementById('sourceCodeArea').value = "<!DOCTYPE html>\n" + document.documentElement.outerHTML;
                    el.classList.add('visible');
                } else {
                    el.classList.remove('visible');
                }
            },
            floatText: (txt, x, y) => {
                const el = document.createElement('div'); el.className = 'floating-text'; el.innerText = txt;
                el.style.left = x+'px'; el.style.top = y+'px'; document.body.appendChild(el);
                setTimeout(()=>el.remove(), 800);
            }
        };

        // --- äº‹ä»¶ ---
        document.addEventListener('touchstart', (e) => {
            if(game.state === 'playing') { e.preventDefault(); game.input(); }
        }, { passive: false });
        document.addEventListener('mousedown', (e) => {
            if(e.target.closest('.btn') || e.target.closest('.shop-item') || e.target.closest('.source-btn') || e.target.closest('.code-window') || e.target.closest('.item-btn')) return;
            game.input();
        });
        document.addEventListener('keydown', (e) => { if(e.code==='Space') game.input(); });

        game.init(); ui.showMenu();
    </script>
</body>
</html>

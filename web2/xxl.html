<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ°´æœæ¶ˆæ¶ˆä¹ - ç•…çˆ½ç‰ˆ</title>
    <!-- ä½¿ç”¨åœ†æ¶¦å¯çˆ±çš„å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <style>
        :root {
            /* é…è‰²ï¼šæ›´æŸ”å’Œçš„ç³–æœè‰² */
            --primary: #FF6B6B;
            --primary-dark: #EE5253;
            --bg-gradient: linear-gradient(135deg, #FF9A9E 0%, #FECFEF 99%, #FECFEF 100%);
            
            /* åŠ¨ç”»æ›²çº¿ï¼šQå¼¹æœå†»æ„Ÿ */
            --ease-elastic: cubic-bezier(0.175, 0.885, 0.32, 1.275);
            --ease-out: cubic-bezier(0.34, 1.56, 0.64, 1);
            
            --tile-size: clamp(40px, 11vw, 55px);
            --gap: 5px;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'ZCOOL KuaiLe', 'Heiti SC', sans-serif; /* ä¸­æ–‡å¯çˆ±å­—ä½“ä¼˜å…ˆ */
        }

        body {
            margin: 0;
            height: 100vh;
            background: var(--bg-gradient);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* --- é¡¶éƒ¨æ•°æ®æ  --- */
        .hud-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 450px;
        }

        .hud-card {
            flex: 1;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 20px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid #FFF;
        }

        .hud-label {
            font-size: 1rem;
            color: #888;
            margin-bottom: 2px;
        }

        .hud-value {
            font-size: 1.8rem;
            color: var(--primary);
            text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
        }

        /* --- æ£‹ç›˜ --- */
        .board-bg {
            background: rgba(255, 255, 255, 0.4);
            padding: 10px;
            border-radius: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border: 2px solid rgba(255,255,255,0.6);
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--gap);
        }

        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            background: #FFF;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--tile-size) * 0.65);
            cursor: pointer;
            position: relative;
            z-index: 10;
            /* 3D æŒ‰é’®æ•ˆæœ */
            box-shadow: 0 4px 0 #E0E0E0, 0 5px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s, background 0.2s;
        }

        /* é€‰ä¸­çŠ¶æ€ */
        .tile.selected {
            background: #FFEAA7;
            transform: translateY(4px); /* æŒ‰ä¸‹æ•ˆæœ */
            box-shadow: 0 0 0 #E0E0E0, inset 0 2px 5px rgba(0,0,0,0.1);
            border: 2px solid #FDcB6E;
        }

        /* åŠ¨ç”»ç±» */
        .tile.moving {
            transition: transform 0.25s var(--ease-out);
            z-index: 100;
        }

        .tile.popping {
            animation: pop 0.3s ease-in forwards;
        }

        .tile.dropping {
            animation: drop 0.5s var(--ease-elastic);
        }

        .tile.shake {
            animation: no-no 0.4s ease-in-out;
            background: #FFD3D3;
        }

        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        @keyframes drop {
            0% { transform: translateY(-50px) scale(0); opacity: 0; }
            60% { transform: translateY(5px) scale(1.1); opacity: 1; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        @keyframes no-no {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-5deg); }
            75% { transform: translateX(5px) rotate(5deg); }
        }

        /* --- æ‚¬æµ®æŒ‰é’® --- */
        .fab-menu {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4);
            cursor: pointer;
            z-index: 200;
            transition: transform 0.2s var(--ease-elastic);
        }

        .fab-menu:active { transform: scale(0.9); }

        /* --- å¼¹çª— --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            z-index: 300;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-box {
            background: #FFF;
            width: 85%;
            max-width: 320px;
            border-radius: 24px;
            padding: 25px;
            text-align: center;
            animation: slideUp 0.3s var(--ease-out);
            box-shadow: 0 20px 50px rgba(0,0,0,0.2);
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-title { font-size: 1.5rem; color: #333; margin: 0 0 20px 0; }

        .cheat-btn {
            width: 100%;
            padding: 15px;
            margin-bottom: 10px;
            border: none;
            border-radius: 15px;
            background: #F0F2F5;
            color: #555;
            font-size: 1.1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 20px;
            cursor: pointer;
            transition: 0.2s;
        }
        
        .cheat-btn span { margin-right: 15px; font-size: 1.4rem; }
        .cheat-btn:active { background: #E1E1E1; transform: scale(0.98); }
        .cheat-btn.highlight { background: #FFF0F0; color: var(--primary); }

        .close-btn {
            margin-top: 15px;
            background: transparent;
            color: #888;
            border: none;
            font-size: 1rem;
            cursor: pointer;
        }

        /* --- æç¤ºæ¡ --- */
        .toast {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translate(-50%, -20px);
            background: rgba(50, 50, 50, 0.9);
            color: #FFF;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 1rem;
            opacity: 0;
            pointer-events: none;
            transition: 0.3s var(--ease-out);
            z-index: 400;
            white-space: nowrap;
        }
        .toast.show { opacity: 1; transform: translate(-50%, 0); }

    </style>
</head>
<body>

    <div class="hud-container">
        <div class="hud-card">
            <span class="hud-label">å‰©ä½™æ­¥æ•°</span>
            <span class="hud-value" id="moves">25</span>
        </div>
        <div class="hud-card">
            <span class="hud-label">å½“å‰å¾—åˆ†</span>
            <span class="hud-value" id="score">0</span>
        </div>
    </div>

    <div class="board-bg">
        <div id="grid"></div>
    </div>

    <!-- ä½œå¼Šèœå•æŒ‰é’® -->
    <div class="fab-menu" onclick="toggleMenu()">âš¡</div>

    <!-- å¼¹çª—èœå• -->
    <div class="modal-overlay" id="menuModal" onclick="if(event.target===this) toggleMenu()">
        <div class="modal-box">
            <h3 class="modal-title">ç¥ç§˜åŠ›é‡ (ä½œå¼Š)</h3>
            <button class="cheat-btn" onclick="execCheat('moves')"><span>ğŸ”‹</span> æ­¥æ•° +10</button>
            <button class="cheat-btn" onclick="execCheat('score')"><span>ğŸ’</span> åˆ†æ•° +5000</button>
            <button class="cheat-btn" onclick="execCheat('shuffle')"><span>ğŸ²</span> å¼ºåˆ¶æ´—ç‰Œ</button>
            <button class="cheat-btn highlight" onclick="execCheat('win')"><span>ğŸ†</span> ç›´æ¥èƒœåˆ©</button>
            <button class="close-btn" onclick="toggleMenu()">å…³é—­èœå•</button>
        </div>
    </div>

    <div class="toast" id="toast">æç¤ºä¿¡æ¯</div>

    <script>
        const width = 8;
        const grid = document.getElementById('grid');
        const scoreEl = document.getElementById('score');
        const movesEl = document.getElementById('moves');
        
        // é™ä½éš¾åº¦ï¼šå‡å°‘ç§ç±»åˆ°5ç§ï¼Œé¢œè‰²åŒºåˆ†åº¦é«˜
        const emojis = ['ğŸ“', 'ğŸŒ', 'ğŸ‡', 'ğŸ¥¥', 'ğŸŠ']; 
        
        let squares = [];
        let score = 0;
        let moves = 25; // ç¨å¾®å¤šç»™å‡ æ­¥
        let selectedIndex = null;
        let isProcessing = false;

        // --- åˆå§‹åŒ–æ¸¸æˆ ---
        function initGame() {
            createBoard();
            // ç¡®ä¿å¼€å±€æ—¢æ²¡æœ‰è‡ªåŠ¨æ¶ˆé™¤ï¼Œä½†åˆå¿…é¡»æœ‰â€œæ´»è·¯â€
            ensurePlayableStart();
        }

        function createBoard() {
            grid.innerHTML = '';
            squares = [];
            for (let i = 0; i < width * width; i++) {
                const tile = document.createElement('div');
                tile.classList.add('tile');
                tile.setAttribute('data-id', i);
                tile.innerHTML = randomEmoji();
                tile.addEventListener('click', () => handleTap(i));
                grid.appendChild(tile);
                squares.push({ dom: tile, val: tile.innerHTML });
            }
        }

        function randomEmoji() {
            return emojis[Math.floor(Math.random() * emojis.length)];
        }

        // --- æ ¸å¿ƒç®—æ³•ï¼šç¡®ä¿æœ‰è§£ ---
        function ensurePlayableStart() {
            let limit = 0;
            // 1. å…ˆæ¶ˆé™¤åˆå§‹çš„è¿å‡»
            cleanInitialMatches();
            // 2. æ£€æŸ¥æ˜¯å¦æœ‰è§£ï¼Œå¦‚æœæ— è§£åˆ™é‡æ–°ç”Ÿæˆ
            while (!hasPossibleMoves() && limit < 100) {
                // æš´åŠ›é‡ç½®ï¼Œç›´åˆ°éšæœºå‡ºä¸€ä¸ªæœ‰è§£çš„ç›˜é¢
                squares.forEach(sq => {
                    sq.dom.innerHTML = randomEmoji();
                    sq.val = sq.dom.innerHTML;
                });
                cleanInitialMatches();
                limit++;
            }
            if(limit >= 100) console.log("Warning: Board generation timed out");
        }

        function cleanInitialMatches() {
            // åå¤æ£€æŸ¥å¹¶æ›¿æ¢ï¼Œç›´åˆ°æ²¡æœ‰å¼€å±€ä¸‰è¿
            while (checkMatchesSimple()) {
                squares.forEach(sq => {
                    if (sq.match) {
                        sq.dom.innerHTML = randomEmoji();
                        sq.val = sq.dom.innerHTML;
                        sq.match = false;
                    }
                });
            }
        }

        // æ™ºèƒ½æ£€æµ‹ï¼šå½“å‰ç›˜é¢æ˜¯å¦æœ‰ä»»æ„ä¸€æ­¥å¯ä»¥æ¶ˆé™¤
        function hasPossibleMoves() {
            // æ¨¡æ‹Ÿæ¯ä¸€ä¸ªæ ¼å­çš„å³æ¢å’Œä¸‹æ¢
            for (let i = 0; i < 64; i++) {
                // å°è¯•å‘å³äº¤æ¢
                if (i % width < width - 1) {
                    if (tryVirtualSwap(i, i + 1)) return true;
                }
                // å°è¯•å‘ä¸‹äº¤æ¢
                if (i < 56) {
                    if (tryVirtualSwap(i, i + width)) return true;
                }
            }
            return false;
        }

        function tryVirtualSwap(idx1, idx2) {
            // è™šæ‹Ÿäº¤æ¢æ•°æ®
            let temp = squares[idx1].val;
            squares[idx1].val = squares[idx2].val;
            squares[idx2].val = temp;

            // æ£€æŸ¥æ˜¯å¦æœ‰è¿å‡»
            let hasMatch = checkMatchesVirtual();

            // æ¢å›æ¥
            temp = squares[idx1].val;
            squares[idx1].val = squares[idx2].val;
            squares[idx2].val = temp;

            return hasMatch;
        }

        // çº¯æ•°æ®å±‚é¢çš„åŒ¹é…æ£€æŸ¥ï¼ˆä¸æ“ä½œDOMï¼‰
        function checkMatchesVirtual() {
            // è¡Œ
            for (let i = 0; i < 64; i++) {
                if (i % width > width - 3) continue;
                if (squares[i].val && squares[i].val === squares[i+1].val && squares[i].val === squares[i+2].val) return true;
            }
            // åˆ—
            for (let i = 0; i < 47; i++) {
                if (squares[i].val && squares[i].val === squares[i+width].val && squares[i].val === squares[i+width*2].val) return true;
            }
            return false;
        }

        // --- äº¤äº’é€»è¾‘ ---
        function handleTap(index) {
            if (isProcessing || moves <= 0) return;
            
            const currentTile = squares[index].dom;

            if (selectedIndex === null) {
                // ç¬¬ä¸€æ¬¡ç‚¹å‡»
                selectedIndex = index;
                currentTile.classList.add('selected');
                vibrate(10);
            } else if (selectedIndex === index) {
                // å–æ¶ˆ
                currentTile.classList.remove('selected');
                selectedIndex = null;
            } else {
                // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼Œåˆ¤æ–­ç›¸é‚»
                const prevIndex = selectedIndex;
                squares[prevIndex].dom.classList.remove('selected');
                selectedIndex = null;

                if (isAdjacent(prevIndex, index)) {
                    performSwap(prevIndex, index);
                } else {
                    // ç‚¹è¿œäº†ï¼Œåˆ‡æ¢ç›®æ ‡
                    currentTile.classList.add('selected');
                    selectedIndex = index;
                    vibrate(10);
                }
            }
        }

        function isAdjacent(i1, i2) {
            const c1 = i1 % width, r1 = Math.floor(i1 / width);
            const c2 = i2 % width, r2 = Math.floor(i2 / width);
            return Math.abs(c1 - c2) + Math.abs(r1 - r2) === 1;
        }

        // --- åŠ¨ç”»ä¸æ‰§è¡Œ ---
        async function performSwap(idx1, idx2) {
            isProcessing = true;
            const tile1 = squares[idx1].dom;
            const tile2 = squares[idx2].dom;

            // è§†è§‰ä½ç½®äº¤æ¢åŠ¨ç”»
            const dx = (idx2 % width - idx1 % width) * 100; // ç®€å•ä½ç§»ï¼Œå‡è®¾æ ¼å†…å¯¹é½
            const dy = (Math.floor(idx2/width) - Math.floor(idx1/width)) * 100;
            
            // ä½¿ç”¨ getBoundingClientRect è®¡ç®—ç²¾ç¡®ä½ç§»ï¼Œé€‚é…å“åº”å¼
            const rect1 = tile1.getBoundingClientRect();
            const rect2 = tile2.getBoundingClientRect();
            const moveX = rect2.left - rect1.left;
            const moveY = rect2.top - rect1.top;

            tile1.classList.add('moving');
            tile2.classList.add('moving');
            tile1.style.transform = `translate(${moveX}px, ${moveY}px)`;
            tile2.style.transform = `translate(${-moveX}px, ${-moveY}px)`;

            await wait(250);

            // é€»è¾‘æ•°æ®äº¤æ¢
            // åŒæ­¥ dom å’Œ å†…éƒ¨ val
            const tempVal = squares[idx1].val;
            squares[idx1].val = squares[idx2].val;
            squares[idx2].val = tempVal;
            
            tile1.innerHTML = squares[idx1].val;
            tile2.innerHTML = squares[idx2].val;

            // é‡ç½®æ ·å¼
            tile1.style.transform = '';
            tile2.style.transform = '';
            tile1.classList.remove('moving');
            tile2.classList.remove('moving');

            // æ£€æŸ¥æ¶ˆé™¤
            if (checkMatchesSimple()) {
                moves--;
                updateHud();
                await processMatches();
            } else {
                // å¤±è´¥å›æ»š - è§†è§‰æ‘‡å¤´
                tile1.classList.add('shake');
                tile2.classList.add('shake');
                vibrate(30);

                // æ•°æ®å›æ»š
                const tempBack = squares[idx1].val;
                squares[idx1].val = squares[idx2].val;
                squares[idx2].val = tempBack;
                // DOM å»¶è¿Ÿå›æ»šä»¥é…åˆåŠ¨ç”»
                await wait(400);
                tile1.innerHTML = squares[idx1].val;
                tile2.innerHTML = squares[idx2].val;
                
                tile1.classList.remove('shake');
                tile2.classList.remove('shake');
                isProcessing = false;
            }
        }

        // å®é™…æ¶ˆé™¤é€»è¾‘ï¼ˆæ ‡è®° DOMï¼‰
        function checkMatchesSimple() {
            let found = false;
            squares.forEach(s => s.match = false);
            // ç®€å•è¡Œæ£€æŸ¥
            for(let i=0; i<64; i++){
                if(i%width > width-3) continue;
                if(squares[i].val === squares[i+1].val && squares[i].val === squares[i+2].val){
                    squares[i].match = squares[i+1].match = squares[i+2].match = true;
                    found = true;
                }
            }
            // ç®€å•åˆ—æ£€æŸ¥
            for(let i=0; i<47; i++){
                if(squares[i].val === squares[i+width].val && squares[i].val === squares[i+width*2].val){
                    squares[i].match = squares[i+width].match = squares[i+width*2].match = true;
                    found = true;
                }
            }
            return found;
        }

        async function processMatches() {
            const matched = squares.filter(s => s.match);
            score += matched.length * 20; // æé«˜åˆ†æ•°
            updateHud();
            vibrate(50);

            // æ’­æ”¾æ¶ˆé™¤åŠ¨ç”»
            matched.forEach(s => s.dom.classList.add('popping'));
            await wait(300);

            // ç§»é™¤å†…å®¹
            matched.forEach(s => {
                s.val = '';
                s.dom.innerHTML = '';
                s.dom.classList.remove('popping');
                s.match = false;
            });

            // ä¸‹è½é€»è¾‘
            await dropTiles();

            // é€’å½’æ£€æŸ¥
            if (checkMatchesSimple()) {
                await wait(200);
                await processMatches();
            } else {
                // æ‰è½ç¨³å®šåï¼Œæ£€æŸ¥æ˜¯å¦æ­»å±€
                checkDeadlock();
                
                isProcessing = false;
                if(moves <= 0) showToast(`æ¸¸æˆç»“æŸï¼å¾—åˆ†: ${score}`);
            }
        }

        async function dropTiles() {
            // ä»ä¸‹å¾€ä¸Š
            for (let c = 0; c < width; c++) {
                for (let r = width - 1; r >= 0; r--) {
                    let idx = r * width + c;
                    if (squares[idx].val === '') {
                        for (let k = r - 1; k >= 0; k--) {
                            let kIdx = k * width + c;
                            if (squares[kIdx].val !== '') {
                                // äº¤æ¢æ•°æ®
                                squares[idx].val = squares[kIdx].val;
                                squares[kIdx].val = '';
                                // æ›´æ–° DOM
                                squares[idx].dom.innerHTML = squares[idx].val;
                                squares[kIdx].dom.innerHTML = '';
                                break;
                            }
                        }
                    }
                }
            }
            // å¡«å……é¡¶éƒ¨
            squares.forEach(s => {
                if(s.val === '') {
                    s.val = randomEmoji();
                    s.dom.innerHTML = s.val;
                    s.dom.classList.add('dropping');
                    setTimeout(() => s.dom.classList.remove('dropping'), 500);
                }
            });
            await wait(250);
        }

        // --- æ ¸å¿ƒä¼˜åŒ–ï¼šæ­»å±€è‡ªåŠ¨æ´—ç‰Œ ---
        function checkDeadlock() {
            if (moves > 0 && !hasPossibleMoves()) {
                showToast("æ— è·¯å¯èµ°ï¼Œæ­£åœ¨æ´—ç‰Œ...");
                setTimeout(() => {
                    shuffleBoard(true); // ä¼ å…¥trueä»£è¡¨è¿™æ˜¯ç³»ç»Ÿè‡ªåŠ¨æ´—ç‰Œï¼Œç¡®ä¿æœ‰è§£
                }, 1000);
            }
        }

        function shuffleBoard(ensureSolvable = false) {
            squares.forEach(s => {
                s.dom.style.transform = 'scale(0)';
            });
            
            setTimeout(() => {
                let limit = 0;
                do {
                    squares.forEach(s => {
                        s.val = randomEmoji();
                        s.dom.innerHTML = s.val;
                    });
                    // é˜²æ­¢æ´—ç‰Œåç›´æ¥ç‚¸
                    while(checkMatchesSimple()) {
                         squares.forEach(s => { 
                             if(s.match) { s.val = randomEmoji(); s.dom.innerHTML=s.val; s.match=false; }
                         });
                    }
                    limit++;
                } while (ensureSolvable && !hasPossibleMoves() && limit < 50);

                squares.forEach(s => {
                    s.dom.style.transform = 'scale(1)';
                });
            }, 300);
        }

        function updateHud() {
            scoreEl.innerText = score;
            movesEl.innerText = moves;
        }

        function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
        function vibrate(ms) { if(navigator.vibrate) navigator.vibrate(ms); }

        // --- èœå•é€»è¾‘ ---
        function toggleMenu() {
            const modal = document.getElementById('menuModal');
            modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        function execCheat(type) {
            toggleMenu();
            switch(type) {
                case 'moves': 
                    moves += 10; 
                    showToast("æ­¥æ•° +10"); 
                    break;
                case 'score': 
                    score += 5000; 
                    showToast("åˆ†æ•°çˆ†æ¶¨ +5000"); 
                    break;
                case 'shuffle': 
                    shuffleBoard(true); 
                    showToast("å·²å¼ºåˆ¶é‡ç½®"); 
                    break;
                case 'win': 
                    score = 88888; 
                    moves = 0; 
                    showToast("æ­å–œå‘è´¢ï¼Œç›´æ¥é€šå…³ï¼"); 
                    break;
            }
            updateHud();
        }

        initGame();

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>高级沙盒模拟器 MD3 v3.2 Ultimate</title>
    <!-- 引入 Material Symbols 图标库 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <style>
        /* ==================== MD3 Design System ==================== */
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;
            --md-sys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1D192B;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-surface-container: #F3EDF7;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-on-surface-variant: #49454F;
            --md-sys-color-outline: #79747E;
            --md-sys-color-outline-variant: #CAC4D0;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-tertiary-container: #FFD8E4;
            --md-sys-color-on-tertiary-container: #31111D;
            --md-sys-elevation-1: 0px 1px 2px 0px rgba(0,0,0,0.3), 0px 1px 3px 1px rgba(0,0,0,0.15);
            --md-sys-elevation-2: 0px 4px 8px 3px rgba(0,0,0,0.15);
            --md-sys-elevation-3: 0px 4px 12px 6px rgba(0,0,0,0.2);
            --md-sys-motion-easing-emphasized: cubic-bezier(0.2, 0.0, 0.0, 1.0);
            --md-sys-motion-easing-spring: cubic-bezier(0.175, 0.885, 0.32, 1.275);
            --md-sys-motion-duration-medium: 400ms;
            --md-dialog-bg: #EEE8F4;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --md-sys-color-primary: #D0BCFF;
                --md-sys-color-on-primary: #381E72;
                --md-sys-color-primary-container: #4F378B;
                --md-sys-color-on-primary-container: #EADDFF;
                --md-sys-color-secondary-container: #4A4458;
                --md-sys-color-on-secondary-container: #E8DEF8;
                --md-sys-color-surface: #1C1B1F;
                --md-sys-color-surface-container: #25232A;
                --md-sys-color-on-surface: #E6E1E5;
                --md-sys-color-on-surface-variant: #CAC4D0;
                --md-sys-color-outline: #938F99;
                --md-sys-color-surface-variant: #49454F;
                --md-sys-color-tertiary-container: #492532;
                --md-sys-color-on-tertiary-container: #FFD8E4;
                --md-dialog-bg: #2B2930;
            }
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; 
            background-color: var(--md-sys-color-surface); 
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', sans-serif; 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden;
        }

        /* Top Bar */
        header {
            height: 64px; 
            display: flex; 
            align-items: center; 
            padding: 0 16px;
            justify-content: space-between; 
            font-weight: 400; 
            font-size: 22px;
            z-index: 10;
            background: var(--md-sys-color-surface);
        }
        
        .header-actions { display: flex; gap: 8px; }

        /* Icon Button */
        .icon-btn {
            width: 40px; height: 40px; 
            border-radius: 20px; 
            border: none; 
            background: transparent;
            color: var(--md-sys-color-on-surface-variant); 
            display: flex; 
            align-items: center; 
            justify-content: center;
            cursor: pointer; 
            position: relative; 
            overflow: hidden;
            transition: background 0.2s var(--md-sys-motion-easing-emphasized);
        }
        .icon-btn:active { background: rgba(var(--md-sys-color-on-surface), 0.12); transform: scale(0.95); }
        .icon-btn.active { background: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container); }
        
        .material-symbols-outlined {
            font-size: 24px;
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
        }

        /* Canvas */
        #game-container {
            flex: 1; 
            position: relative; 
            background: #000; 
            margin: 0 16px 16px;
            border-radius: 16px; 
            overflow: hidden; 
            box-shadow: var(--md-sys-elevation-2);
            touch-action: none; 
            cursor: crosshair;
            border: 1px solid var(--md-sys-color-outline-variant);
        }
        
        canvas { 
            width: 100%; height: 100%; 
            image-rendering: pixelated; 
            display: block; 
            transform-origin: 0 0;
            transition: none; 
        }

        /* Controls */
        .controls-area {
            background-color: var(--md-sys-color-surface-container); 
            padding: 16px 16px 24px;
            border-radius: 28px 28px 0 0; 
            display: flex; 
            flex-direction: column; 
            gap: 16px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05); 
            z-index: 20;
            transition: transform 0.3s var(--md-sys-motion-easing-emphasized);
        }

        .tool-row {
            display: flex; gap: 12px; align-items: center;
        }

        /* Chips */
        .chip-scroll { display: flex; overflow-x: auto; gap: 8px; padding-bottom: 4px; scrollbar-width: none; flex: 1; }
        .chip-scroll::-webkit-scrollbar { display: none; }
        
        .chip {
            height: 32px; 
            padding: 0 16px; 
            border-radius: 8px; 
            border: 1px solid var(--md-sys-color-outline);
            background: transparent; 
            color: var(--md-sys-color-on-surface-variant); 
            font-size: 14px; 
            font-weight: 500;
            display: flex; 
            align-items: center; 
            justify-content: center;
            white-space: nowrap; 
            cursor: pointer; 
            transition: all 0.2s var(--md-sys-motion-easing-emphasized);
            gap: 8px;
        }
        
        .chip:active { transform: scale(0.95); }
        .chip.active {
            background: var(--md-sys-color-secondary-container); 
            color: var(--md-sys-color-on-secondary-container); 
            border-color: transparent;
        }
        
        .tool-toggle {
            height: 40px; width: 40px; border-radius: 12px;
            border: 1px solid var(--md-sys-color-outline);
            background: transparent;
            color: var(--md-sys-color-on-surface);
            display: none; 
            align-items: center; justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tool-toggle.visible { display: flex; }
        .tool-toggle.active {
            background: var(--md-sys-color-tertiary-container);
            color: var(--md-sys-color-on-tertiary-container);
            border-color: transparent;
        }

        /* Buttons */
        .btn-filled {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            height: 40px;
            border-radius: 20px;
            font-weight: 500;
            font-size: 14px;
            width: 100%;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            transition: transform 0.2s var(--md-sys-motion-easing-emphasized);
            box-shadow: var(--md-sys-elevation-1);
        }
        .btn-filled:active { transform: scale(0.97); opacity: 0.9; }

        .btn-text {
            background: transparent;
            color: var(--md-sys-color-primary);
            border: none;
            height: 40px;
            padding: 0 12px;
            border-radius: 20px;
            font-weight: 500;
            cursor: pointer;
        }

        /* Bottom Sheet */
        #more-sheet {
            position: fixed; bottom: -100%; left: 0; right: 0; 
            background: var(--md-sys-color-surface-container);
            border-radius: 28px 28px 0 0; 
            padding: 24px; 
            transition: bottom var(--md-sys-motion-duration-medium) var(--md-sys-motion-easing-emphasized);
            z-index: 100; 
            max-height: 75vh; 
            overflow-y: auto;
            box-shadow: var(--md-sys-elevation-3);
        }
        #more-sheet.open { bottom: 0; }
        
        .grid-elements {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(72px, 1fr)); gap: 12px;
        }
        .element-card {
            display: flex; flex-direction: column; align-items: center; padding: 12px 8px;
            background: var(--md-sys-color-surface); 
            border-radius: 12px; gap: 8px; cursor: pointer;
            font-size: 12px; text-align: center;
            color: var(--md-sys-color-on-surface);
            transition: transform 0.2s var(--md-sys-motion-easing-emphasized), background 0.2s;
            border: 1px solid transparent;
        }
        .element-card:active { background: var(--md-sys-color-surface-variant); transform: scale(0.95); }
        .element-dot { width: 32px; height: 32px; border-radius: 50%; border: 1px solid rgba(128,128,128,0.2); transition: transform 0.2s; }
        .element-card:hover .element-dot { transform: scale(1.1); }

        .backdrop {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.4);
            z-index: 90; opacity: 0; pointer-events: none; transition: opacity 0.3s;
            backdrop-filter: blur(2px);
        }
        .backdrop.open { opacity: 1; pointer-events: auto; }

        .slider-container { display: flex; align-items: center; gap: 16px; font-size: 14px; color: var(--md-sys-color-on-surface-variant); }
        input[type=range] { flex: 1; accent-color: var(--md-sys-color-primary); height: 4px; border-radius: 2px; }
        
        .shape-btn {
            width: 32px; height: 32px; border-radius: 8px; border: 1px solid var(--md-sys-color-outline);
            background: transparent; display: flex; align-items: center; justify-content: center;
            color: var(--md-sys-color-on-surface-variant); cursor: pointer;
        }
        .shape-btn.active { background: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container); border:none;}

        /* Dialogs */
        .dialog-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 200; display: none;
            align-items: center; justify-content: center; opacity: 0;
            transition: opacity 0.3s;
            backdrop-filter: blur(4px);
        }
        .dialog-overlay.show { display: flex; opacity: 1; }
        
        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .dialog {
            background: var(--md-dialog-bg); width: 85%; max-width: 340px;
            border-radius: 28px; padding: 24px; 
            box-shadow: var(--md-sys-elevation-3);
            display: flex; flex-direction: column;
            transform-origin: center;
        }
        .dialog-overlay.show .dialog { 
            animation: popIn 0.4s var(--md-sys-motion-easing-spring) forwards;
        }
        
        .dialog-title { font-size: 24px; margin: 0 0 16px 0; font-weight: 400; color: var(--md-sys-color-on-surface); }
        .dialog-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 16px 0; border-bottom: 1px solid var(--md-sys-color-outline-variant);
            cursor: pointer; color: var(--md-sys-color-on-surface);
        }
        .dialog-item:last-child { border-bottom: none; }
        
        /* Switch */
        .switch { position: relative; display: inline-block; width: 52px; height: 32px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--md-sys-color-surface-variant); 
            border: 2px solid var(--md-sys-color-outline);
            transition: .4s var(--md-sys-motion-easing-emphasized); border-radius: 32px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px; left: 6px; bottom: 6px;
            background-color: var(--md-sys-color-outline); transition: .4s var(--md-sys-motion-easing-emphasized); border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--md-sys-color-primary); border-color: var(--md-sys-color-primary); }
        input:checked + .slider:before { transform: translateX(20px); background-color: var(--md-sys-color-on-primary); width: 24px; height: 24px; left: 2px; bottom: 2px; }

        .select-input {
            background: transparent;
            border: 1px solid var(--md-sys-color-outline);
            color: var(--md-sys-color-on-surface);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            font-family: inherit;
        }

    </style>
</head>
<body>

    <header>
        <span>物理沙盒 v3.2</span>
        <div class="header-actions">
            <button class="icon-btn" onclick="togglePause()" id="pause-btn" title="暂停/开始">
                <span class="material-symbols-outlined">pause</span>
            </button>
            <button class="icon-btn" onclick="openSettings()" title="设置">
                <span class="material-symbols-outlined">settings</span>
            </button>
            <button class="icon-btn" onclick="clearCanvas()" title="清空画布">
                <span class="material-symbols-outlined">delete</span>
            </button>
        </div>
    </header>

    <div id="game-container">
        <canvas id="sandbox"></canvas>
    </div>

    <div class="controls-area">
        <div class="slider-container">
            <span class="material-symbols-outlined" style="font-size:20px;">brush</span>
            <input type="range" min="1" max="10" value="3" id="brushSize">
            <button class="shape-btn" id="shape-toggle" onclick="toggleBrushShape()" title="切换形状 (圆/方)">
                <span class="material-symbols-outlined" style="font-size:18px;">circle</span>
            </button>
            <span id="fps-counter" style="display:none; width:60px; text-align:right; font-variant-numeric: tabular-nums;">60 FPS</span>
        </div>

        <div class="tool-row">
            <!-- Zoom/Pan Tool Toggle -->
            <button class="tool-toggle" id="view-mode-btn" onclick="toggleViewMode()" title="视图模式 (移动/缩放)">
                <span class="material-symbols-outlined">pan_tool</span>
            </button>
            
            <div class="chip-scroll" id="quick-bar"></div>
        </div>

        <button class="btn-filled" onclick="toggleSheet(true)">
            <span class="material-symbols-outlined">grid_view</span>
            更多元素
        </button>
    </div>

    <!-- Backdrop -->
    <div class="backdrop" id="backdrop" onclick="closeAllOverlays()"></div>

    <!-- More Elements Sheet -->
    <div id="more-sheet">
        <div style="width:32px; height:4px; background:var(--md-sys-color-outline); opacity:0.4; margin:-10px auto 20px; border-radius:2px;"></div>
        <h3 style="margin:0 0 16px; font-size:22px; font-weight:400;">元素库</h3>
        <div class="grid-elements" id="all-elements-grid"></div>
    </div>

    <!-- Settings Dialog -->
    <div class="dialog-overlay" id="settings-overlay" onclick="closeSettings(event)">
        <div class="dialog">
            <h2 class="dialog-title">设置</h2>
            
            <div class="dialog-item">
                <div style="display:flex; align-items:center; gap:12px;">
                    <span class="material-symbols-outlined">speed</span>
                    <span>显示 FPS</span>
                </div>
                <label class="switch">
                    <input type="checkbox" id="fps-toggle" onchange="toggleFPS()">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="dialog-item">
                <div style="display:flex; align-items:center; gap:12px;">
                    <span class="material-symbols-outlined">zoom_in</span>
                    <span>启用缩放功能</span>
                </div>
                <label class="switch">
                    <input type="checkbox" id="zoom-toggle" onchange="toggleZoomFeature()">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="dialog-item">
                <div style="display:flex; align-items:center; gap:12px;">
                    <span class="material-symbols-outlined">public</span>
                    <span>零重力模式</span>
                </div>
                <label class="switch">
                    <input type="checkbox" id="gravity-toggle" onchange="toggleGravity()">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="dialog-item">
                <div style="display:flex; align-items:center; gap:12px;">
                    <span class="material-symbols-outlined">aspect_ratio</span>
                    <span>画质 / 分辨率</span>
                </div>
                <select class="select-input" id="res-select" onchange="changeResolution(this.value)">
                    <option value="8">低 (大颗粒)</option>
                    <option value="4" selected>中 (默认)</option>
                    <option value="2">高 (精细)</option>
                </select>
            </div>

            <div style="text-align:right; margin-top:24px;">
                <button class="btn-text" onclick="document.getElementById('settings-overlay').classList.remove('show'); toggleBackdrop(false);">关闭</button>
            </div>
        </div>
    </div>

    <script>
        // ================= 配置与元素定义 =================
        let canvasScale = 4; 
        let isPaused = false;
        let zoomFeatureEnabled = false;
        let isViewMode = false;
        let brushShape = 'circle';
        let zeroGravity = false;
        
        // Zoom/Pan State
        let scale = 1;
        let pPanning = false;
        let pointX = 0, pointY = 0, startX = 0, startY = 0;
        let lastPinchDist = 0;
        
        const TYPES = { EMPTY: 0, SOLID: 1, POWDER: 2, LIQUID: 3, GAS: 4, ENERGY: 5 };

        const ELEMENTS = {
            AIR:   { id: 0, name: '空气', type: TYPES.EMPTY, color: [0,0,0,0] },
            
            // --- 固体 ---
            STONE: { id: 1, name: '石头', type: TYPES.SOLID, color: [120, 120, 120], variance: 20 },
            WOOD:  { id: 2, name: '木头', type: TYPES.SOLID, color: [139, 69, 19], flammable: true, burnRate: 0.05 },
            ICE:   { id: 3, name: '冰块', type: TYPES.SOLID, color: [173, 216, 230], meltRate: 0.015 },
            C4:    { id: 4, name: 'C-4',  type: TYPES.SOLID, color: [180, 200, 100], explosive: true, radius: 40 },
            FUSE:  { id: 5, name: '导火索', type: TYPES.SOLID, color: [100, 50, 50], flammable: true, burnRate: 0.3 },
            PLANT: { id: 6, name: '植物', type: TYPES.SOLID, color: [34, 139, 34], flammable: true, burnRate: 0.1 },
            VINE:  { id: 7, name: '藤蔓', type: TYPES.SOLID, color: [60, 180, 60], flammable: true, burnRate: 0.08, vine: true }, 
            WAX:   { id: 8, name: '蜡',   type: TYPES.SOLID, color: [240, 240, 220], meltRate: 0.1, flammable: true, burnRate: 0.05 },
            ELEC:  { id: 9, name: '雷电', type: TYPES.SOLID, color: [255, 255, 0], life: 5, hot: true, variance: 0, isElec: true },
            GLASS: { id: 14, name: '玻璃', type: TYPES.SOLID, color: [200, 255, 255, 100], variance: 0, reflect: true },
            URAN:  { id: 15, name: '铀',   type: TYPES.SOLID, color: [50, 255, 50], hot: true, variance: 50, radioactive: true },
            TNT:   { id: 17, name: 'TNT',  type: TYPES.SOLID, color: [200, 50, 50], explosive: true, radius: 25 },
            TERM:  { id: 81, name: '白蚁', type: TYPES.SOLID, color: [180, 150, 100], isBug: true },
            NA:    { id: 82, name: '钠',   type: TYPES.SOLID, color: [200, 200, 220], reactive: true },
            
            // --- 特殊固体 (v3.1 & v3.2 新增) ---
            CLONE: { id: 42, name: '克隆', type: TYPES.SOLID, color: [255, 200, 0], clone: true },
            VOID:  { id: 43, name: '黑洞', type: TYPES.SOLID, color: [20, 0, 40], void: true, gravityPull: true },
            DRYICE:{ id: 44, name: '干冰', type: TYPES.SOLID, color: [220, 230, 255], cold: true, sublimate: true },
            THERM: { id: 46, name: '铝热剂',type: TYPES.POWDER,color: [160, 100, 100], flammable: true, burnRate: 0.8, superHot: true },
            LIFE:  { id: 47, name: '生命', type: TYPES.SOLID, color: [255, 0, 255], isLife: true },
            NUKE:  { id: 48, name: '核弹', type: TYPES.SOLID, color: [50, 80, 50], explosive: true, radius: 80, fallout: true },

            // --- 粉末 ---
            SAND:  { id: 10, name: '沙子', type: TYPES.POWDER, color: [226, 197, 139], variance: 20, density: 1.5 },
            GUNP:  { id: 11, name: '火药', type: TYPES.POWDER, color: [60, 60, 60], explosive: true, radius: 10 },
            SALT:  { id: 12, name: '盐',   type: TYPES.POWDER, color: [240, 240, 240], density: 1.2 },
            SEED:  { id: 13, name: '种子', type: TYPES.POWDER, color: [100, 255, 100], density: 1.1, grow: true },
            ASH:   { id: 16, name: '灰烬', type: TYPES.POWDER, color: [100, 100, 100], density: 1.3 },
            SPARK: { id: 39, name: '火花', type: TYPES.POWDER, color: [255, 215, 0], life: 15, gravity: 0.5 },
            ANTIG: { id: 83, name: '反重力', type: TYPES.POWDER, color: [100, 200, 255], gravity: -1 }, 
            VIRUS: { id: 41, name: '病毒', type: TYPES.POWDER, color: [120, 40, 140], infect: true },
            FWORK: { id: 45, name: '烟花', type: TYPES.POWDER, color: [255, 100, 150], thruster: true, life: 70 },

            // --- 液体 ---
            WATER: { id: 20, name: '水',   type: TYPES.LIQUID, color: [64, 164, 223], density: 1.0, variance: 10 },
            OIL:   { id: 21, name: '石油', type: TYPES.LIQUID, color: [50, 40, 20], density: 0.8, flammable: true, burnRate: 0.15 },
            ACID:  { id: 22, name: '酸液', type: TYPES.LIQUID, color: [124, 252, 0], density: 1.0, acid: true },
            LAVA:  { id: 23, name: '岩浆', type: TYPES.LIQUID, color: [255, 69, 0], density: 2.0, hot: true },
            SLIME: { id: 25, name: '粘液', type: TYPES.LIQUID, color: [0, 200, 50], density: 1.1, viscous: true }, 
            NITRO: { id: 85, name: '液氮', type: TYPES.LIQUID, color: [160, 220, 255], density: 0.9, cold: true },
            MERCURY:{ id: 40, name: '水银', type: TYPES.LIQUID, color: [160, 160, 170], density: 13.5, conductive: true },

            // --- 气体/特效 ---
            FIRE:  { id: 30, name: '火焰', type: TYPES.GAS, color: [255, 100, 0], variance: 80, hot: true, life: 30 },
            STEAM: { id: 31, name: '蒸汽', type: TYPES.GAS, color: [200, 220, 255, 120], life: 400, condense: true, dispersion: 0.3 }, 
            SMOKE: { id: 32, name: '烟雾', type: TYPES.GAS, color: [80, 80, 80, 100], life: 120, dispersion: 0.1 },
            METH:  { id: 33, name: '甲烷', type: TYPES.GAS, color: [150, 255, 150, 100], flammable: true, burnRate: 0.9, density: 0.1, dispersion: 0.4 },
            ACIDG: { id: 36, name: '酸气', type: TYPES.GAS, color: [150, 255, 50, 150], acid: true, life: 300, dispersion: 0.2 }, 
            PHOTON:{ id: 49, name: '光子', type: TYPES.ENERGY, color: [255, 255, 255], isPhoton: true },

            ERASER:{ id: 99, name: '橡皮', type: TYPES.SOLID, color: [255,255,255,50], isEraser: true }
        };

        let currentEl = ELEMENTS.SAND;
        const canvas = document.getElementById('sandbox');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let width, height;
        let grid, imageData, buffer32;

        function initGrid() {
            const container = document.getElementById('game-container');
            width = Math.floor(container.clientWidth / canvasScale);
            height = Math.floor(container.clientHeight / canvasScale);
            
            canvas.width = width;
            canvas.height = height;
            
            grid = new Int32Array(width * height).fill(0);
            imageData = ctx.createImageData(width, height);
            buffer32 = new Uint32Array(imageData.data.buffer);
            resetZoom();
        }
        
        const idx = (x, y) => x + y * width;
        const inB = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
        
        // ================= 引擎核心逻辑 =================
        function update() {
            if (!isPaused) {
                // 生命游戏等自动机需要两步缓冲，这里为了性能使用原地更新+随机顺序模拟
                // 或者我们可以从下到上扫描
                for (let y = height - 1; y >= 0; y--) {
                    updateRow(y);
                }
            }
            draw();
            requestAnimationFrame(update);
        }

        function updateRow(y) {
            // 随机扫描方向，防止粒子产生偏向性
            const scanLeft = Math.random() > 0.5;
            const startX = scanLeft ? 0 : width - 1;
            const endX = scanLeft ? width : -1;
            const stepX = scanLeft ? 1 : -1;

            for (let x = startX; x !== endX; x += stepX) {
                const i = idx(x, y);
                const id = grid[i];
                if (id === 0) continue;

                const el = getElById(id);
                if (!el) continue;

                // 交互反应 (火烧木头、酸腐蚀等)
                if (processInteractions(x, y, i, el)) continue;

                // 零重力模式下
                if (zeroGravity) {
                    if (el.isBug || el.isElec || el.thruster || el.isPhoton) {
                         // 允许特殊元素移动
                    } else {
                        continue; 
                    }
                }

                // 运动逻辑
                if (el.isPhoton) movePhoton(x, y, i, el);
                else if (el.isLife) updateLife(x, y, i, el);
                else if (el.gravity === -1) moveAntiGravity(x, y, i, el);
                else if (el.isElec) moveElectricity(x, y, i, el);
                else if (el.thruster) moveThruster(x, y, i, el);
                else if (el.type === TYPES.POWDER) movePowder(x, y, i, el);
                else if (el.type === TYPES.LIQUID) moveLiquid(x, y, i, el);
                else if (el.type === TYPES.GAS) moveGas(x, y, i, el);
                else if (el.isBug) {
                        const dir = Math.random() < 0.25 ? -1 : (Math.random() > 0.75 ? 1 : 0);
                        const dy = Math.random() < 0.25 ? -1 : (Math.random() > 0.75 ? 1 : 0);
                        if (inB(x+dir, y+dy) && grid[idx(x+dir, y+dy)] === 0) swap(i, idx(x+dir, y+dy));
                }
            }
        }

        // ================= 复杂的交互逻辑 =================
        function processInteractions(x, y, i, el) {
            // 随机跳过部分检查，优化性能
            if (Math.random() > 0.45) return false; 
            const neighbors = [{x:x, y:y-1}, {x:x, y:y+1}, {x:x-1, y:y}, {x:x+1, y:y}];

            // 1. 克隆 (Clone) - 复制接触的非空、非克隆物体
            if (el.clone) {
                 for(let n of neighbors) {
                     if(inB(n.x, n.y)) {
                         const nid = grid[idx(n.x, n.y)];
                         if(nid !== 0 && nid !== el.id) {
                             const freeSpots = neighbors.filter(p => inB(p.x, p.y) && grid[idx(p.x, p.y)] === 0);
                             if(freeSpots.length > 0) {
                                 const spot = freeSpots[Math.floor(Math.random()*freeSpots.length)];
                                 grid[idx(spot.x, spot.y)] = nid; 
                             }
                         }
                     }
                 }
                 return false; 
            }

            // 2. 黑洞 (Void) - 强力吞噬 + 引力
            if (el.void) {
                // 吞噬接触的
                for(let n of neighbors) {
                    if(inB(n.x, n.y) && grid[idx(n.x, n.y)] !== 0 && grid[idx(n.x, n.y)] !== el.id) {
                        grid[idx(n.x, n.y)] = 0;
                    }
                }
                // 引力：随机拉取周围的一个粒子过来 (范围更大)
                if (Math.random() < 0.2) {
                    const range = 5;
                    const rx = x + Math.floor(Math.random()*range*2 - range);
                    const ry = y + Math.floor(Math.random()*range*2 - range);
                    if(inB(rx, ry) && grid[idx(rx, ry)] !== 0 && grid[idx(rx, ry)] !== el.id) {
                         // 将远处的粒子拉到黑洞旁边
                         const emptyNeighbor = neighbors.find(n => inB(n.x, n.y) && grid[idx(n.x, n.y)] === 0);
                         if(emptyNeighbor) {
                             grid[idx(emptyNeighbor.x, emptyNeighbor.y)] = grid[idx(rx, ry)];
                             grid[idx(rx, ry)] = 0;
                         }
                    }
                }
                return false;
            }

            // 3. 铝热剂 (Thermite) - 超高温熔穿
            if (el.superHot) {
                 // 自动燃烧
                 if (Math.random() < 0.05) grid[i] = ELEMENTS.FIRE.id;
                 for(let n of neighbors) {
                    if(inB(n.x, n.y) && grid[idx(n.x, n.y)] !== 0) {
                        const target = getElById(grid[idx(n.x, n.y)]);
                        // 熔穿石头、甚至原本不可破坏的边界(如果未定义边界的话)
                        if (target.id !== el.id && target.id !== ELEMENTS.FIRE.id) {
                            if(Math.random() < 0.2) {
                                grid[idx(n.x, n.y)] = ELEMENTS.LAVA.id;
                                if(Math.random() < 0.5) grid[i] = ELEMENTS.FIRE.id; // 自己消耗掉
                                return true;
                            }
                        }
                    }
                 }
            }

            // 4. 病毒 (Virus) - 感染
            if (el.infect) {
                for(let n of neighbors) {
                    if(inB(n.x, n.y)) {
                        const nid = grid[idx(n.x, n.y)];
                        if(nid !== 0 && nid !== el.id) {
                             const target = getElById(nid);
                             if(target && (target.id === ELEMENTS.PLANT.id || target.id === ELEMENTS.WOOD.id || target.id === ELEMENTS.VINE.id || target.id === ELEMENTS.SEED.id || target.isLife)) {
                                 if(Math.random() < 0.1) grid[idx(n.x, n.y)] = el.id; 
                             }
                        }
                    }
                }
            }

            // 5. 干冰 (Dry Ice) - 升华
            if (el.sublimate) {
                for(let n of neighbors) {
                    if(inB(n.x, n.y) && grid[idx(n.x, n.y)] === ELEMENTS.WATER.id) {
                        grid[idx(n.x, n.y)] = ELEMENTS.ICE.id;
                    }
                }
                if (Math.random() < 0.02) {
                    grid[i] = ELEMENTS.STEAM.id; 
                    return true;
                }
            }

            // 藤蔓生长
            if (el.vine) {
                if (Math.random() < 0.02) { 
                    const growDirs = [{x:x, y:y+1}, {x:x-1, y:y}, {x:x+1, y:y}, {x:x, y:y-1}];
                    const target = growDirs[Math.floor(Math.random() * growDirs.length)];
                    if(inB(target.x, target.y) && grid[idx(target.x, target.y)] === 0) {
                        grid[idx(target.x, target.y)] = ELEMENTS.VINE.id;
                    }
                }
            }

            // 铀辐射
            if (el.radioactive) {
                for (let n of neighbors) {
                    if (inB(n.x, n.y) && grid[idx(n.x, n.y)] !== 0 && grid[idx(n.x, n.y)] !== el.id) {
                        if (Math.random() < 0.05) {
                            grid[idx(n.x, n.y)] = ELEMENTS.GAS.id; 
                            grid[i] = Math.random() < 0.5 ? ELEMENTS.FIRE.id : el.id;
                            return true;
                        }
                    }
                }
            }
            
            // 液氮冷冻
            if (el.cold && !el.sublimate) {
                for(let n of neighbors) {
                    if(inB(n.x, n.y)) {
                         const nid = grid[idx(n.x, n.y)];
                         if (nid === ELEMENTS.WATER.id) {
                            grid[idx(n.x, n.y)] = ELEMENTS.ICE.id;
                            grid[i] = ELEMENTS.GAS.id; 
                            return true;
                         }
                    }
                }
                if (Math.random() < 0.05) { grid[i] = ELEMENTS.GAS.id; return true; }
            }

            // 钠 + 水 剧烈爆炸
            if (el.reactive) {
                 for(let n of neighbors) {
                    if(inB(n.x, n.y) && grid[idx(n.x, n.y)] === ELEMENTS.WATER.id) {
                        explode(x, y, 20); return true;
                    }
                }
            }

            // 白蚁
            if (el.isBug) {
                for(let n of neighbors) {
                    if(inB(n.x, n.y) && (grid[idx(n.x, n.y)] === ELEMENTS.WOOD.id || grid[idx(n.x, n.y)] === ELEMENTS.VINE.id)) {
                        grid[idx(n.x, n.y)] = 0; return true;
                    }
                }
            }

            // 蒸汽高空冷凝
            if (el.condense) {
                if (y < height * 0.1 && Math.random() < 0.01) {
                    grid[i] = ELEMENTS.WATER.id; return true;
                }
            }

            // 生命周期 (火、烟、电、烟花)
            if (el.life) {
                // 烟花逻辑
                if (el.thruster) {
                    // 烟花不直接在这里死，而是在移动逻辑里处理，或者这里小概率爆炸
                }
                else if (Math.random() < 0.08) { 
                    if (el.id === ELEMENTS.FIRE.id) {
                        grid[i] = ELEMENTS.SMOKE.id; 
                    } else {
                        grid[i] = 0;
                    }
                    return true;
                }
            }

            // 燃烧/爆炸检测
            if (el.flammable || el.explosive) {
                let touchedFire = false;
                for (let n of neighbors) {
                    if (inB(n.x, n.y)) {
                        const nid = grid[idx(n.x, n.y)];
                        const nel = getElById(nid);
                        if (nel && (nel.hot || nel.id === ELEMENTS.LAVA.id || nel.id === ELEMENTS.ELEC.id || nel.id === ELEMENTS.SPARK.id || nel.superHot)) {
                            touchedFire = true;
                            break;
                        }
                    }
                }
                if (touchedFire) {
                    if (el.explosive) { 
                        explode(x, y, el.radius); 
                        if(el.fallout) { // 核辐射
                            for(let k=0; k<50; k++) {
                                let rx = x + Math.floor(Math.random()*60-30);
                                let ry = y + Math.floor(Math.random()*60-30);
                                if(inB(rx, ry) && grid[idx(rx, ry)] === 0) grid[idx(rx, ry)] = ELEMENTS.URAN.id;
                            }
                        }
                        return true; 
                    }
                    else if (el.flammable && Math.random() < el.burnRate) {
                        grid[i] = ELEMENTS.FIRE.id; 
                        if (Math.random() < 0.1) grid[i] = ELEMENTS.ASH.id;
                        return true;
                    }
                }
            }

            // 蜡熔化
            if (el.id === ELEMENTS.WAX.id) {
                 for (let n of neighbors) {
                    if (inB(n.x, n.y)) {
                        const nid = grid[idx(n.x, n.y)];
                        const nel = getElById(nid);
                        if(nel && nel.hot && Math.random() < el.meltRate) { 
                             grid[i] = ELEMENTS.OIL.id; return true; 
                        }
                    }
                 }
            }

            // 种子生长
            if (el.grow) {
                const down = idx(x, y+1);
                if (y+1 < height && (grid[down] === ELEMENTS.SAND.id || grid[down] === ELEMENTS.WATER.id)) {
                    if(Math.random() < 0.03) { grid[i] = ELEMENTS.PLANT.id; return true; }
                }
            }

            // 岩浆 + 水
            if (el.id === ELEMENTS.LAVA.id) {
                const up = idx(x, y-1);
                if (y-1 >= 0 && grid[up] === ELEMENTS.WATER.id) {
                    grid[up] = ELEMENTS.STEAM.id; grid[i] = ELEMENTS.STONE.id; return true;
                }
            }

            // 酸腐蚀
            if (el.acid) {
                const checkIdx = idx(x, el.type === TYPES.GAS ? y-1 : y+1); 
                if (checkIdx >= 0 && checkIdx < grid.length && grid[checkIdx] !== 0) {
                    const targetEl = getElById(grid[checkIdx]);
                    if (targetEl.id !== el.id && targetEl.id !== ELEMENTS.GLASS.id && targetEl.id !== ELEMENTS.ACIDG.id && targetEl.type !== TYPES.EMPTY && !targetEl.void) {
                        if (Math.random() < 0.1) {
                            grid[checkIdx] = 0; 
                            if(Math.random() < 0.3) grid[i] = 0; 
                            return true;
                        }
                    }
                }
            }

            // 冰融化
            if (el.id === ELEMENTS.ICE.id) {
                 if (Math.random() < 0.002) { grid[i] = ELEMENTS.WATER.id; return true; } 
                 for (let n of neighbors) {
                     if(inB(n.x,n.y)) {
                         const nel = getElById(grid[idx(n.x, n.y)]);
                         if (nel && nel.hot) { grid[i] = ELEMENTS.WATER.id; return true; }
                     }
                 }
            }

            return false;
        }

        function explode(cx, cy, r) {
            grid[idx(cx, cy)] = ELEMENTS.FIRE.id;
            for (let y = -r; y <= r; y++) {
                for (let x = -r; x <= r; x++) {
                    if (x*x + y*y <= r*r) {
                        const px = cx + x; const py = cy + y;
                        if (inB(px, py)) {
                            const rand = Math.random();
                            // 彩色烟花特效
                            if(currentEl && currentEl.id === ELEMENTS.FWORK.id) {
                                if (rand > 0.5) grid[idx(px, py)] = ELEMENTS.SPARK.id;
                                else grid[idx(px, py)] = 0;
                            } else {
                                // 普通爆炸
                                if (rand > 0.6) grid[idx(px, py)] = ELEMENTS.FIRE.id;
                                else if (rand > 0.3) grid[idx(px, py)] = ELEMENTS.SMOKE.id;
                                else grid[idx(px, py)] = 0;
                            }
                        }
                    }
                }
            }
        }

        // ================= 运动与物理逻辑 =================

        // 康威生命游戏 (简化版，随机更新)
        function updateLife(x, y, i, el) {
            let nInfo = 0;
            const neighborOffsets = [
                [-1,-1], [0,-1], [1,-1],
                [-1, 0],         [1, 0],
                [-1, 1], [0, 1], [1, 1]
            ];
            
            for(let off of neighborOffsets) {
                let nx = x + off[0], ny = y + off[1];
                if(inB(nx, ny) && grid[idx(nx, ny)] === ELEMENTS.LIFE.id) nInfo++;
            }

            // 死亡规则
            if (nInfo < 2 || nInfo > 3) {
                 if(Math.random() < 0.2) grid[i] = 0; // 稍微滞后死亡，避免闪烁过快
            }
            
            // 繁殖规则 (寻找周围空位变成生命)
            for(let off of neighborOffsets) {
                let nx = x + off[0], ny = y + off[1];
                if(inB(nx, ny) && grid[idx(nx, ny)] === 0) {
                     // 检查这个空位的邻居数
                     let emptyN = 0;
                     for(let off2 of neighborOffsets) {
                         let nnx = nx + off2[0], nny = ny + off2[1];
                         if(inB(nnx, nny) && grid[idx(nnx, nny)] === ELEMENTS.LIFE.id) emptyN++;
                     }
                     if(emptyN === 3) grid[idx(nx, ny)] = ELEMENTS.LIFE.id;
                }
            }
        }

        // 光子逻辑
        function movePhoton(x, y, i, el) {
            // 光子移动极快，一次移动多格
            const speed = 4;
            // 简单的随机方向光子 (更复杂的需要存储dx/dy数据，这里用简化版)
            // 假设光子默认向上或随机扩散
            let dx = (Math.random() > 0.5 ? 1 : -1) * (Math.random() > 0.5 ? 1 : 0);
            let dy = (Math.random() > 0.5 ? 1 : -1);
            if(dx===0 && dy===0) dy = -1;

            let currX = x, currY = y;
            grid[i] = 0; // 离开当前位置

            for(let s=0; s<speed; s++) {
                currX += dx; currY += dy;
                if(!inB(currX, currY)) return; // 飞出边界
                
                const targetId = grid[idx(currX, currY)];
                if(targetId !== 0) {
                    const t = getElById(targetId);
                    if(t.reflect) { // 反射 (简化: 随机反弹)
                        dx = -dx; dy = -dy;
                    } else if (t.id !== el.id) {
                        // 击中物体
                        if(t.flammable) grid[idx(currX, currY)] = ELEMENTS.FIRE.id;
                        else if(Math.random() < 0.1) grid[idx(currX, currY)] = 0; // 甚至可能烧掉
                        return; // 光子消失
                    }
                }
            }
            if(inB(currX, currY) && grid[idx(currX, currY)] === 0) {
                grid[idx(currX, currY)] = el.id;
            }
        }

        function moveAntiGravity(x, y, i, el) {
            const up = idx(x, y-1);
            if (y-1 >= 0) {
                if (grid[up] === 0) { swap(i, up); }
                else if (getElById(grid[up]).type !== TYPES.SOLID) { swap(i, up); }
            }
        }

        function moveThruster(x, y, i, el) {
            // 烟花向上加速
            if (Math.random() < 0.15) {
                grid[i] = ELEMENTS.SMOKE.id; // 尾迹
                const up = idx(x, y-2);
                if (y-2 >= 0 && grid[up] === 0) grid[up] = el.id;
                else if (Math.random() < 0.2) explode(x, y, 15); // 撞到东西爆炸
            } else {
                 const up = idx(x, y-1);
                 if (y-1 >= 0 && grid[up] === 0) swap(i, up);
            }
        }

        function moveElectricity(x, y, i, el) {
            const jumpX = Math.floor(Math.random() * 3) - 1;
            const jumpY = Math.floor(Math.random() * 3) - 1;
            if (inB(x+jumpX, y+jumpY) && grid[idx(x+jumpX, y+jumpY)] === 0) {
                swap(i, idx(x+jumpX, y+jumpY));
            }
        }

        function movePowder(x, y, i, el) {
            const down = idx(x, y+1);
            if (y+1 < height) {
                const targetId = grid[down]; const targetEl = getElById(targetId);
                if (targetId === 0 || (targetEl && targetEl.type === TYPES.LIQUID && targetEl.density < el.density) || (targetEl && targetEl.type === TYPES.GAS)) {
                    swap(i, down);
                } else {
                    const dir = Math.random() > 0.5 ? 1 : -1;
                    const sideDown = idx(x+dir, y+1);
                    if (inB(x+dir, y+1)) {
                         const sideId = grid[sideDown]; const sideEl = getElById(sideId);
                         if (sideId === 0 || (sideEl && sideEl.type === TYPES.LIQUID && sideEl.density < el.density)) {
                             swap(i, sideDown);
                         }
                    }
                }
            }
        }

        function moveLiquid(x, y, i, el) {
            if (el.viscous && Math.random() < 0.6) return; 

            const down = idx(x, y+1);
            if (y+1 < height) {
                const targetId = grid[down]; const targetEl = getElById(targetId);
                if (targetId === 0 || (targetEl && targetEl.type === TYPES.GAS)) { swap(i, down); return; } 
                else if (targetEl && targetEl.type === TYPES.LIQUID && el.density > targetEl.density) {
                    swap(i, down); return; 
                }
            }
            const dir = Math.random() > 0.5 ? 1 : -1;
            const side = idx(x+dir, y);
            if (inB(x+dir, y) && grid[side] === 0) swap(i, side);
        }

        /**
         * v3.2 优化后的气体物理
         * 模拟真实的“布朗运动”加“浮力”
         */
        function moveGas(x, y, i, el) {
            // 1. 浮力滞后 (模拟空气阻力)
            if (Math.random() < 0.35) return;

            const dirY = -1; // 向上
            const nextY = y + dirY;
            
            // 2. 向上运动 (主趋势)
            if (nextY >= 0) {
                const upIdx = idx(x, nextY);
                const upEl = getElById(grid[upIdx]);
                // 如果上方是空，或者上方是液体/固体(比气体重)
                if (grid[upIdx] === 0 || (upEl && upEl.type === TYPES.LIQUID)) {
                    // 增加一点水平随机性，不要直直的上去
                    if (Math.random() > 0.2) {
                        swap(i, upIdx);
                        return;
                    }
                }
            }
            
            // 3. 扩散与湍流 (Turbulence)
            const dir = Math.random() > 0.5 ? 1 : -1;
            
            // 优先往斜上方钻
            if (inB(x+dir, nextY) && grid[idx(x+dir, nextY)] === 0) {
                swap(i, idx(x+dir, nextY));
                return;
            }
            
            // 纯水平扩散 (形成云层)
            if (inB(x+dir, y) && grid[idx(x+dir, y)] === 0) {
                if (Math.random() < (el.dispersion || 0.6)) {
                    swap(i, idx(x+dir, y));
                }
            }
        }

        function swap(i, j) { const temp = grid[i]; grid[i] = grid[j]; grid[j] = temp; }
        function getElById(id) { return Object.values(ELEMENTS).find(e => e.id === id); }

        function draw() {
            buffer32.fill(0xFF000000); 
            for (let i = 0; i < grid.length; i++) {
                const id = grid[i];
                if (id !== 0) {
                    const el = getElById(id);
                    if (el) {
                        const [r, g, b, a=255] = el.color;
                        let R=r, G=g, B=b;
                        let v = 0;
                        if(el.variance) v = (Math.random() - 0.5) * el.variance;
                        else if (el.type === TYPES.LIQUID) v = (Math.random() - 0.5) * 10;
                        
                        // 火焰/光子/烟花 闪烁特效
                        if (el.id === ELEMENTS.FIRE.id || el.id === ELEMENTS.FWORK.id || el.id === ELEMENTS.PHOTON.id) {
                            if (Math.random() > 0.5) { R=Math.min(255, R+50); G=Math.min(255, G+50); } 
                            else { R=Math.max(0, R-20); G=Math.max(0, G-20); } 
                            v = (Math.random()-0.5) * 40;
                        }
                        
                        buffer32[i] = (a << 24) | (clamp(B+v) << 16) | (clamp(G+v) << 8) | clamp(R+v);
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
            frameCount++;
        }
        
        let frameCount = 0;
        setInterval(() => {
            if(showFps) document.getElementById('fps-counter').innerText = `${frameCount} FPS`;
            frameCount = 0;
        }, 1000);

        const clamp = v => Math.max(0, Math.min(255, v | 0));

        // ================= UI 操作 =================
        let isDrawing = false;
        let showFps = false;
        
        // 快捷栏元素 - 加入新元素
        const QUICK_KEYS = ['SAND', 'WATER', 'STONE', 'FIRE', 'LIFE', 'PHOTON', 'NUKE', 'VOID', 'MERCURY', 'VIRUS', 'THERM', 'ERASER'];

        function initUI() {
            initGrid();
            
            const quickBar = document.getElementById('quick-bar');
            const allGrid = document.getElementById('all-elements-grid');

            QUICK_KEYS.forEach(k => quickBar.appendChild(createChip(ELEMENTS[k], k)));

            Object.keys(ELEMENTS).forEach(k => {
                if (k === 'AIR' || k === 'SPARK' || k === 'ASH') return;
                const el = ELEMENTS[k];
                const card = document.createElement('div');
                card.className = 'element-card';
                card.innerHTML = `
                    <div class="element-dot" style="background:rgba(${el.color[0]},${el.color[1]},${el.color[2]},1)"></div>
                    <span>${el.name}</span>
                `;
                card.onclick = () => selectElement(k);
                allGrid.appendChild(card);
            });
            updateActiveState();
        }

        function createChip(el, key) {
            const btn = document.createElement('button');
            btn.className = 'chip'; btn.dataset.key = key; 
            btn.innerHTML = `${el.name}`;
            btn.onclick = () => selectElement(key);
            return btn;
        }

        function selectElement(key) {
            currentEl = ELEMENTS[key];
            updateActiveState();
            toggleSheet(false);
        }

        function updateActiveState() {
            const currentKey = Object.keys(ELEMENTS).find(k => ELEMENTS[k] === currentEl);
            document.querySelectorAll('.chip').forEach(c => {
                if(c.dataset.key === currentKey) {
                    c.classList.add('active');
                    if(!c.querySelector('.material-symbols-outlined')) {
                        const check = document.createElement('span');
                        check.className = 'material-symbols-outlined';
                        check.style.fontSize = '18px';
                        check.innerText = 'check';
                        c.prepend(check);
                    }
                } else {
                    c.classList.remove('active');
                    const check = c.querySelector('.material-symbols-outlined');
                    if(check) check.remove();
                }
            });
        }

        function changeResolution(val) {
            canvasScale = parseInt(val);
            initGrid();
        }

        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('pause-btn');
            btn.innerHTML = isPaused ? 
                '<span class="material-symbols-outlined">play_arrow</span>' : 
                '<span class="material-symbols-outlined">pause</span>';
        }

        function toggleBrushShape() {
            brushShape = brushShape === 'circle' ? 'square' : 'circle';
            const btn = document.getElementById('shape-toggle');
            if(brushShape === 'square') {
                btn.innerHTML = '<span class="material-symbols-outlined" style="font-size:18px;">square</span>';
            } else {
                btn.innerHTML = '<span class="material-symbols-outlined" style="font-size:18px;">circle</span>';
            }
        }

        function toggleGravity() {
            zeroGravity = document.getElementById('gravity-toggle').checked;
        }

        // ================= Zoom / Pan Logic =================
        function toggleZoomFeature() {
            zoomFeatureEnabled = document.getElementById('zoom-toggle').checked;
            const btn = document.getElementById('view-mode-btn');
            if (zoomFeatureEnabled) {
                btn.classList.add('visible');
            } else {
                btn.classList.remove('visible');
                isViewMode = false;
                btn.classList.remove('active');
                resetZoom();
            }
        }

        function toggleViewMode() {
            isViewMode = !isViewMode;
            const btn = document.getElementById('view-mode-btn');
            if (isViewMode) btn.classList.add('active');
            else btn.classList.remove('active');
        }

        function resetZoom() {
            scale = 1; pointX = 0; pointY = 0;
            updateTransform();
        }

        function updateTransform() {
            canvas.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
        }

        function handleInput(e) {
            e.preventDefault();

            // Zoom/Pan Handling
            if (isViewMode && zoomFeatureEnabled) {
                // Pinch Zoom
                if(e.touches && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (e.type === 'touchstart') {
                        lastPinchDist = dist;
                    } else if (e.type === 'touchmove') {
                        if (lastPinchDist > 0) {
                            const delta = dist / lastPinchDist;
                            scale *= delta;
                            scale = Math.max(1, Math.min(10, scale));
                            lastPinchDist = dist;
                            updateTransform();
                        }
                    }
                    return;
                }

                // Pan
                if (e.type === 'mousedown' || e.type === 'touchstart') {
                    pPanning = true;
                    startX = (e.touches ? e.touches[0].clientX : e.clientX) - pointX;
                    startY = (e.touches ? e.touches[0].clientY : e.clientY) - pointY;
                } else if (e.type === 'mousemove' || e.type === 'touchmove') {
                    if (!pPanning) return;
                    pointX = (e.touches ? e.touches[0].clientX : e.clientX) - startX;
                    pointY = (e.touches ? e.touches[0].clientY : e.clientY) - startY;
                    updateTransform();
                } else if (e.type === 'mouseup' || e.type === 'touchend') {
                    pPanning = false;
                }
                return; 
            }

            // Drawing Handling
            if (!isDrawing && e.type !== 'mousemove' && e.type !== 'touchmove') return;
            if (!isDrawing && (e.type === 'mousemove' || e.type === 'touchmove')) return;

            const rect = canvas.getBoundingClientRect(); 
            let cx = e.touches ? e.touches[0].clientX : e.clientX;
            let cy = e.touches ? e.touches[0].clientY : e.clientY;
            
            const x = Math.floor((cx - rect.left) / (rect.width / width));
            const y = Math.floor((cy - rect.top) / (rect.height / height));
            const r = parseInt(document.getElementById('brushSize').value);

            if (brushShape === 'square') {
                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        drawPixel(x + dx, y + dy);
                    }
                }
            } else {
                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        if (dx*dx + dy*dy <= r*r) {
                            drawPixel(x + dx, y + dy);
                        }
                    }
                }
            }
        }

        function drawPixel(px, py) {
             if (inB(px, py)) {
                if (currentEl.isEraser) grid[idx(px, py)] = 0;
                else if (grid[idx(px, py)] === 0 || currentEl.type === TYPES.SOLID || currentEl.void || currentEl.isLife) { 
                    if (Math.random() > 0.05) grid[idx(px, py)] = currentEl.id;
                }
            }
        }

        canvas.addEventListener('wheel', (e) => {
            if (!zoomFeatureEnabled || !isViewMode) return;
            e.preventDefault();
            const xs = (e.clientX - pointX) / scale;
            const ys = (e.clientY - pointY) / scale;
            const delta = -e.deltaY;
            
            (delta > 0) ? (scale *= 1.1) : (scale /= 1.1);
            if(scale < 1) scale = 1; if(scale > 10) scale = 10;
            
            pointX = e.clientX - xs * scale;
            pointY = e.clientY - ys * scale;
            updateTransform();
        }, {passive: false});

        canvas.addEventListener('mousedown', e => { if(!isViewMode) isDrawing=true; handleInput(e); });
        canvas.addEventListener('mousemove', handleInput);
        window.addEventListener('mouseup', () => { isDrawing=false; pPanning=false; });
        
        canvas.addEventListener('touchstart', e => { if(!isViewMode) isDrawing=true; handleInput(e); }, {passive:false});
        canvas.addEventListener('touchmove', handleInput, {passive:false});
        window.addEventListener('touchend', () => { isDrawing=false; pPanning=false; lastPinchDist=0; });

        function toggleSheet(open) {
            const sheet = document.getElementById('more-sheet');
            toggleBackdrop(open);
            if(open) sheet.classList.add('open'); else sheet.classList.remove('open');
        }
        function toggleBackdrop(show) {
            const bd = document.getElementById('backdrop');
            if(show) bd.classList.add('open'); else bd.classList.remove('open');
        }
        function openSettings() {
            document.getElementById('settings-overlay').classList.add('show');
            toggleBackdrop(true);
        }
        function closeSettings(e) {
            if (e.target.id === 'settings-overlay') {
                document.getElementById('settings-overlay').classList.remove('show');
                toggleBackdrop(false);
            }
        }
        function closeAllOverlays() {
            toggleSheet(false);
            document.getElementById('settings-overlay').classList.remove('show');
        }
        function toggleFPS() {
            showFps = document.getElementById('fps-toggle').checked;
            document.getElementById('fps-counter').style.display = showFps ? 'block' : 'none';
        }
        function clearCanvas() { grid.fill(0); resetZoom(); }

        initUI();
        requestAnimationFrame(update);
    </script>
</body>
</html>
